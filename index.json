[
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/1_account.html",
	"title": "AWS account 생성하기",
	"tags": [],
	"description": "",
	"content": "Workshop에서 사용하고자 하는 AWS 계정은 새로운 IAM 역할을 만들수 있어야 하고 다른 IAM 권한 범위를 지정할 수 있어야 합니다.  이미 AWS 계정을 가지고 있고, IAM 관리자 접속 권한이 있다면 이 페이지를 넘어가도 좋습니다.   관리자 접속 권한 계정이 없다면: 새로 하나 만듭시다.\n AWS 계정을 가지게 되었다면, 남은 워크샵 단계를 잘 따르고 있는 확인해보세요.\nAWS 계정에 대한 관리자 권한이 있는 IAM user : 워크샵에서 사용할 IAM user를 만듭니다.\n 사용자 상세정보를 입력합니다.:  AdministratorAccess IAM 정책 연결:  create the new user 클릭:  Take note of the login URL and save:   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/",
	"title": "Amplify Web App Workshop",
	"tags": [],
	"description": "",
	"content": " AWS Amplify와 AWS AppSync로  사진 공유 웹 어플리케이션 구현 \n환영합니다! 이번 워크샵에서 React를 사용하여 사용자들이 사진을 업로드하고 공유하는 data-driven 기반의 안전한 사진 갤러리 웹 어플리케이션을 구현합니다. AWS AppSync를 이용하여 Amazon DynamoDB에 백업된 데이터를 GraphQL API를 통하여 빠르게 가져오고 실행합니다. AWS Amplify 라이브러리를 사용하여 사용자를 인증하고, API와 통신하며, 사진 업로드 관리를 어떻게 하는지 시연합니다. 마지막으로 Amazon Rekognition으로 AI 기반 오브젝트 태그를 추가하여 사용자가 수동으로 검색 데이터 입력하지 않아도 사진을 찾아주도록 구현합니다. "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums/5_managing_albums.html",
	"title": "Managing Albums",
	"tags": [],
	"description": "",
	"content": " At this point, we have a web app that authenticates users and a secure GraphQL API endpoint that lets us create and read Album data. It\u0026rsquo;s time to connect the two together!\nAs we saw above, [AWS Amplify](https://aws.github.io/aws-amplify/) is an open source JavaScript library that makes it very easy to integrate a number of cloud services into your web or React Native apps. We'll start by using its [Connect React component](https://aws-amplify.github.io/docs/js/api#connect) to take care of automatically querying our GraphQL API and providing data for our React components to use when rendering.  The Amplify CLI has already taken care of making sure that our *src/aws-exports.js* file contains all of the configuration we'll need to pass to the Amplify JS library in order to talk to the AppSync API. All we'll need to do is add some new code to interact with the API.  Here\u0026rsquo;s what it will look like when we render our list of Albums:\nUpdating our App Let\u0026rsquo;s update our front-end to: - allow users to create albums - show a list of albums - allow users to click into an album to view its details\nFrom the photo-albums directory, run npm install --save react-router-dom to add a new dependency for routing.\nUsually, we'd create separate files for each of our components, but here we'll just keep everything together so we can see all of the front end code in one place.  Replace photo-albums/src/App.js with the following updated version: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;;  import Amplify, { API, graphqlOperation } from \u0026#39;aws-amplify\u0026#39;; import { Connect, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!) { getAlbum(id: $id) { id name } } `; class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { render() { return ( \u0026lt;Connect query={graphqlOperation(GetAlbum, { id: this.props.id })}\u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.getAlbum) return; return \u0026lt;AlbumDetails album={data.getAlbum} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AlbumDetails extends Component { render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;p\u0026gt;TODO: Allow photo uploads\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;TODO: Show photos for this album\u0026lt;/p\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } }  export default withAuthenticator(App, {includeGreetings: true});\nWhat we changed in src/App.js  Imported the Connect component from aws-amplify-react\n Imported more presentational components from semantic-ui-react\n Imported API and graphqlOperation from aws-amplify\n Imported routing components from react-router-dom\n Added makeComparator to allow us to sanely sort strings in JS\n Added new components: NewAlbum, AlbumsList, AlbumsDetailsLoader, AlbumDetails, AlbumsListLoader\n Added GraphQL queries and mutations: ListAlbums, SubscribeToNewAlbums, GetAlbum\n Updated the App component to present different components based on the current URL route\n  Try out the app Check out the app now and try out the new features:\n View the list of albums\n Create a new album and see it appear in the albums list\n Click into an album to see the beginnings of our Album details view\n When viewing an Album, click \u0026lsquo;Back to Albums list\u0026rsquo; to go home\n  The loading magic here comes from [AWS Amplify's *Connect* component](https://aws-amplify.github.io/docs/js/api#connect) (which we imported from the *aws-amplify-react* package). All we need to do is pass this component a GraphQL query operation in its query prop. It takes care of running that query when the component mounts, and it passes information down to a child function via the data, loading, and errors arguments. We use those values to render appropriately, either showing some loading text or passing the successfully fetched data to our *AlbumsList* component.  The *listAlbums* query we're above using passes in a very high limit argument. This is because we can just load all of the albums in one request and sort the albums alphabetically on the client-side (instead of dealing with paginated DynamoDB responses). This keeps the *AlbumsList* code pretty simple, so it's probably worth the trade off in terms of performance or network cost.  Also worth noting is how we're leveraging an AppSync real-time subscription to automatically refresh the list of albums whenever a new album is created.   Our GraphQL schema contains a *Subscription* type with a bunch of subscriptions that were auto-generated back when we had AWS AppSync create the resources (like the DynamoDB table and the AWS AppSync resolvers) for our *Album* type. One of these the _onCreateAlbum_ subscription.   The _subscription_ and _onSubscriptionMsg_ properties on the _Connect_ component tell it to subscribe to the _onCreateAlbum_ event data and update the data for AlbumsList accordingly.   The content for the subscription property looks very similar to what we provided for the query property previously; it just contains a query specifying the subscription we want to listen to and what fields we'd like back when new data arrives. The only slightly tricky bit is that we also need to define a handler function to react to new data from the subscription, and that function needs to return a new set of data that the _Connect_ component will use to refresh our _ListAlbums_ component. This is what we've done above.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/10_workspace.html",
	"title": "Cloud9 Workspace 생성하기",
	"tags": [],
	"description": "",
	"content": " AWS Cloud9은 cloud-based의 통합 개발 환경(IDE)입니다. 브라우저에서 바로 코드를 작성하고 실행시키고, 디버깅할수 있습니다. Cloud9은 코드 편집기, 디버거와 터미널을 제공합니다. 또한 Javascript, Python, PHP 등의 인기 있는 프로그래밍언어를 위한 필수적인 도구들이 미리 패키징 되어 제공됩니다. 무엇보다도 새로운 프로젝트 시작을 위해 설치 파일이 필요하거나, 개발 환경 설정이 필요하지 않습니다.\nThe Cloud9의 작업영역은 AWS root 계정이 아닌, Administrator 권한을 가진 IAM user에 의해서 작성 되어야 합니다. root 계정이 아닌 IAM User로 로그인 하여 작업 중인게 맞는지 꼭 확인하세요.  광고 차단기, Javascript 비활성화 도구 및 차단 추적기 등은 Cloud9 에서는 비활성화 하세요. 작업 영역에 영향을 줄 수 있습니다.  새 환경 만들기  Cloud9 web console 로 이동 Create environment 선택 workshop으로 이름을 붙이고 Next step으로 넘어가세요. Create a new instance for environment (EC2) 선택하고 t2.medium을 고르세요 모든 환경 설정을 있는 그대로 두고 Next step로 이동합니다. Create environment를 클릭합니다.  Layout 정리 작업 환경이 나타나면, welcome tab을 닫고 레이아웃을 본인에게 맞게 커스터마이징 하세요. 작업 영역을 낮추고, 새로운 terminal 탭을 메인 작업 영역에 띄웁니다. : 당신의 작업 영역은 이제 이렇게 보일거에요.: Cloud9 workspace 메뉴에서 View / Themes / Solarized / Solarized Dark 테마를 직접 선택할 수 있습니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/10_what_we_built.html",
	"title": "Congratulations!",
	"tags": [],
	"description": "",
	"content": " While no application is really ever done, we\u0026rsquo;ve certainly come a long way toward building a shareable photo albums web app!\nHere\u0026rsquo;s a reminder of everything we accomplished. We:\n Started with a simple React web app\n Added user authentication with a complete sign up and sign in flow\n Created a GraphQL API to securely manage photo albums backed by DynamoDB tables\n Added the ability to create and view albums\n Added the ability to upload photos to an album, complete with automatic thumbnail creation\n Introduced \u0026lsquo;load more\u0026hellip;\u0026rsquo; pagination for albums with many photos\n Added automatic label detection for photos\n Added the ability to search for all photos for a given label (scoped by each user\u0026rsquo;s album permissions)\n Built a production-ready version of the app and deployed it to S3 for web hosting\n  The backend for our photo albums app is entirely serverless, which means it\u0026rsquo;s extremely cost efficient, scalable, and highly available thanks to services from AWS.\nNot bad for a few hours of work!\nPlease give yourself a huge pat on the back for making it all the way to the end!\nWhat will you build next? "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/10_creating_a_photo_processor_lambda.html",
	"title": "Creating a Photo Processor Lambda function",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s make a photo processor lambda function so that we can resize our photos.\nWhen following the instructions below, **you must name your lambda function _workshopphotoprocessor_**.   Later, we'll edit some CloudFormation templates, and the function name **workshopphotoprocessor** is hard coded to make it easier for this workshop (less edits that you'll have to do).   From the photo-albums directory, run: amplify function add and respond to the prompts the same way as shown below. Make sure you press Enter before continuing to step 2:\n$ amplify function add Using service: Lambda, provided by: awscloudformation ? Provide a friendly name for your resource to be used as a label for this category in the project: workshopphotoprocessor ? Provide the AWS Lambda function name: workshopphotoprocessor ? Choose the function template that you want to use: Hello world function ? Do you want to edit the local lambda function now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js ? Press enter to continue \u0026lt;Enter\u0026gt; Successfully added resource workshopphotoprocessor locally. Replace /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js with the following: // amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; function storePhotoInfo(item) { const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const id = uuidv4(); const item = { id: id, owner: metadata.owner, photoAlbumId: metadata.albumid, bucket: bucketName, thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  \n Replace /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/package.json with the following:\n{ \u0026#34;name\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The photo uploads processor\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;sharp\u0026#34;: \u0026#34;^0.20.2\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^3.3.2\u0026#34; } } From the photo-albums directory, run: amplify function build and press Enter to confirm. This will take care of installing the dependencies in our Lambda function\u0026rsquo;s package.json.\n Create photo-albums/amplify/backend/function/workshopphotoprocessor/parameters.json and paste this content into it:\n{ \u0026#34;S3UserfilesBucketName\u0026#34;: \u0026#34;REPLACE_WITH_USERFILES_BUCKET_NAME\u0026#34;, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: \u0026#34;REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN\u0026#34; } In parameters.json that you just created, replace REPLACE_WITH_USERFILES_BUCKET_NAME with the name of the S3 Userfiles bucket created by Amplify.\nTo find this value, look in photo-albums/src/aws-exports.js and find the aws_user_files_s3_bucket key.\n In parameters.json, also replace REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN with the name ARN of the DynamoDB table used by AppSync for the Photo data type.\nTo find this value, go to the Data Sources section in your AppSync API console, find the PhotoTable entry and click on the link in its Resource column (which takes you to the associated DynamoDB table), then look in the bottom of the Overview tab for the ARN of the table.\n Replace photo-albums/amplify/backend/function/workshopphotoprocessor/workshopphotoprocessor-cloudformation-template.json with the following: { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Lambda resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; } }, \t\u0026#34;Resources\u0026#34;: { \u0026#34;LambdaFunction\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::Lambda::Function\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;Handler\u0026#34;: \u0026#34;index.handler\u0026#34;, \u0026#34;FunctionName\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;Role\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34;, \u0026#34;Arn\u0026#34; ] }, \u0026#34;Runtime\u0026#34;: \u0026#34;nodejs8.10\u0026#34;, \u0026#34;Timeout\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;Environment\u0026#34;: { \u0026#34;Variables\u0026#34;: { \u0026#34;ENV\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34;}, \u0026#34;THUMBNAIL_WIDTH\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;THUMBNAIL_HEIGHT\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;DYNAMODB_PHOTOS_TABLE_ARN\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } } \t} }, \u0026#34;LambdaExecutionRole\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Role\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;RoleName\u0026#34;: \u0026#34;photoalbumsLambdaRole91d2faf3\u0026#34;, \u0026#34;AssumeRolePolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;lambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: [ \u0026#34;sts:AssumeRole\u0026#34; ] } ] } } }, \u0026#34;lambdaexecutionpolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;lambda-execution-policy\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*\u0026#34;, { \u0026#34;region\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, \u0026#34;account\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;lambda\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForPhotoAlbums\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForPhotoAlbums\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:s3:::${S3UserfilesBucketName}/*\u0026#34;, { \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3UserfilesBucketName\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForDynamo\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForDynamo\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } ] } } }, \u0026#34;RekognitionDetectLabels\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;RekognitionDetectLabels\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;rekognition:detectLabels\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] \t} } }\t}, \u0026#34;Outputs\u0026#34;: { \u0026#34;Name\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } }, \u0026#34;Arn\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaFunction\u0026#34;, \u0026#34;Arn\u0026#34; ] } }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n From the photo-albums directory, run: amplify push to deploy our new function.\n Wait for the deploy to finish. This step usually only takes about a minute or two.\n  What we changed  Created a parameters.json file to pass some values into the Photo Processor function\u0026rsquo;s CloudFormation template\n Added parameters env, S3UserfilesBucketName, and DynamoDBPhotosTableArn to the Photo Processor function\u0026rsquo;s CloudFormation template\n Added environment variables to the Photo Processor function\u0026rsquo;s configuration: ENV, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, DYNAMODB_PHOTOS_TABLE_ARN\n Added an AllPrivsForPhotoAlbums IAM policy to grant the function\u0026rsquo;s role read and write access to the S3 bucket containing our photos\n Added an AllPrivsForDynamo IAM policy to grant the function\u0026rsquo;s role read and write access to the DynamoDB table containing information about our photos\n Added a RekognitionDetectLabels IAM policy to grant the function\u0026rsquo;s role permission to use the detectLabels API from Amazon Rekognition. This policy isn\u0026rsquo;t used yet, but we\u0026rsquo;re going to add it here for convenience while we\u0026rsquo;re working with this file so we won\u0026rsquo;t need to come back and add it when we get to the next section that involves automatically tagging our photos with AI.\n  The AWS Amplify CLI manages the cloud resources in our project by generating CloudFormation templates for us. CloudFormation templates are very helpful, because they specify all of our project's infrastrucutre as code in the form of JSON and/or YAML files. In this workshop, we'll continue to make edits to some of these generated CloudFormation templates like we did in the steps above.   Beware that not all changes are safe to make, and the Amplify CLI may overwrite edits you make in some CloudFormation templates. All of the changes we make in this workshop will persist and won't get overwritten by Amplify because we're not issuing any commands to re-configure or remove any of the resources we're editing, but it's good to remember that this sort of thing _can_ happen if you attempt to use the CLI to re-configure a resource you've already generated with Amplify.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/10_rekognition.html",
	"title": "Integrating Amazon Rekognition",
	"tags": [],
	"description": "",
	"content": " It would be great if we could find images without having to manually tag them with descriptions of their contents. Luckily, adding this feature is pretty easy thanks to Amazon Rekognition. We can use the DetectLabels API \u0026ndash; if we give it a photo, it will respond with a list of appropriate labels for the image. Perfect!\n**Amazon Rekognition's DetectLabels Quick Summary**  You pass the input image as base64-encoded image bytes or as a reference to an image in an Amazon S3 bucket. If you use the AWS CLI to call Amazon Rekognition operations, passing image bytes is not supported. The image must be either a PNG or JPEG formatted file.  For each object, scene, and concept the API returns one or more labels. Each label provides the object name, and the level of confidence that the image contains the object. For example, suppose the input image has a lighthouse, the sea, and a rock. The response includes all three labels, one for each object.  {Name: lighthouse, Confidence: 98.4629}  {Name: rock,Confidence: 79.2097}  {Name: sea,Confidence: 75.061}  Integrating Rekognition with the Photo Processor Lambda Let\u0026rsquo;s add Amazon Rekognition integration in to our photo_processor lambda function.\nReplace amplify/backend/function/workshopphotoprocessor/src/index.js with the following version:\n// photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const Rekognition = new AWS.Rekognition(); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; async function getLabelNames(bucketName, key) { let params = { Image: { S3Object: { Bucket: bucketName, Name: key } }, MaxLabels: 50, MinConfidence: 70 }; const detectionResult = await Rekognition.detectLabels(params).promise(); const labelNames = detectionResult.Labels.map((l) =\u0026gt; l.Name.toLowerCase()); return labelNames; } function storePhotoInfo(item) {  const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const labelNames = await getLabelNames(bucketName, sizes.fullsize.key); const id = uuidv4(); const item = {  id: id, owner: metadata.owner, labels: labelNames, photoAlbumId: metadata.albumid, bucket: bucketName,  thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  What we changed  Created an instance of AWS.Rekognition to interact with the Amazon Rekognition API\n Added the getLabelNames function to use Rekognition.detectLabels to return a list of appropriate labels for a given photo on S3\n Updated the processPrcord function to use the getLabelNames function to get labels for the photo and include them in the item record it persists to DynamoDB\n  Our Photo Processor code now uses Amazon Rekognition\u0026rsquo;s detectLabels API. But because we already added permissions for this action in the previous section, we won\u0026rsquo;t need to update the CloudFormation template again.\nRe-deploying the Photo Processor Lambda From the photo-albums directory, run: amplify push to deploy an updated version of the Photo Processor function.\nAfter the deploy finishes, try adding a new photo to an album. Then, go look at its row in the PhotoTable in DynamoDB and see if you see a labels property for the new upload. Hopefully you see some relevant labels for the photo!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/10_lightbox_photos.html",
	"title": "Making a Lightbox for Viewing Fullsize Photos",
	"tags": [],
	"description": "",
	"content": " One thing we haven\u0026rsquo;t yet addressed in our app is adding the ability for users to click on a photo thumbnail to see a larger version of the photo. Since we already have the fullsize and the thumbnail data available to query from our API, all we need to do is update our front end application with a few more lines of code.\nUpdating the front end Replace photo-albums/src/App.js with the following updated version: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); }  photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)}  /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt;  \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported the Container and Modal components from semantic-ui-react\n Added additional fields to our GetAlbum GraphQL query to fetch fullsize photo info\n Updated the PhotosList component to track the currently selected photo and pass it to a nested Lightbox component\n Created a Lightbox component to render a selected photo\u0026rsquo;s fullsize content in a modal display\n  Try out the app Check out the app again and try clicking on any photo thumbnails. You should now see a fullsize version pop up. Clicking the photo will dismiss it and return to the thumbnails view.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/10_setting_up_appsync.html",
	"title": "Setting Up AppSync",
	"tags": [],
	"description": "",
	"content": " Now that we have authenticated users, let\u0026rsquo;s make an API for creating albums. These albums won\u0026rsquo;t have any photos in them just yet, just a name and an association with the username that created them, but it\u0026rsquo;s another clear step toward putting our app together.\nTo build our API we'll use [AWS AppSync](https://aws.amazon.com/appsync/), a managed GraphQL service for building data-driven apps. If you're not yet familiar with the basics of GraphQL, you should take a few minutes and check out [https://graphql.github.io/learn/](https://graphql.github.io/learn/) before continuing, or use the site to refer back to when you have questions as you read along.  Adding an AWS AppSync API From the photo-albums directory, run amplify add api and respond to the prompts like this:\n$ amplify add api ? Please select from one of the below mentioned services GraphQL ? Provide API name: photoalbums ? Choose an authorization type for the API Amazon Cognito User Pool ? Do you have an annotated GraphQL schema? No ? Do you want a guided schema creation? Yes ? What best describes your project: One-to-many relationship (e.g., “Blogs” with “Posts” and “Comments”) ? Do you want to edit the schema now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/api/photoalbums/schema.graphql ? Press enter to continue  Declaring the GraphQL Schema Below is a schema that will suit our needs for storing and querying Albums and Photos.\n Paste this into photo-albums/amplify/backend/api/photoalbums/schema.graphql, replacing the example schema content. Remember to save the file. Note: in Cloud9 you can mouse-over the file name in the terminal, click it, and select \u0026lsquo;Open\u0026rsquo;.\n# amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! } type PhotoS3Info { key: String! width: Int! height: Int! } Return to your command prompt and press Enter once to continue\n Run amplify push and confirm you\u0026rsquo;d like to continue with the updates\n When prompted about code generation, select \u0026lsquo;No\u0026rsquo;\n Wait a few minutes while Amplify takes care of provisioning new resources for us.\n  At this point, without having to write any code, we now have a GraphQL API that will let us perform CRUDL operations on our Album and Photo data types!  But don't worry, the way AWS AppSync is resolving fields into data isn't hidden from us. Each resolver that was automatically generated is available for us to edit as we see fit, and we'll get to that later. For now, let's try out adding some albums and then retrieving them all as a list.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/10_adding_auth_back.html",
	"title": "Setting Up the Back End",
	"tags": [],
	"description": "",
	"content": " Now that we have a simple React app, let\u0026rsquo;s let users sign up and sign in to our app. They won\u0026rsquo;t be able to do anything yet, but it will be helpful to have this in place so that when we add in the ability to query our backend API, we\u0026rsquo;ll know which users are accessing our system.\nThe AWS Amplify CLI makes it easy for us to add cloud capabilities to our web and mobile apps, with SDKs available for React and React Native, iOS, and Android. To get started, we'll create a new application and enable user authentication. We'll then wire things up in our app using the open-source [AWS Amplify](https://aws-amplify.github.io/) JavaScript library, which the AWS Amplify CLI will take care of configuring for us; all we have to do is use it in our React app. AWS Amplify contains some nice abstractions for working with cloud services, and it has some helpful React components we'll use in our app.  Here\u0026rsquo;s what the sign-in screen will look like: Initializing Amplify On the command line, in the photo-albums directory:\n Be sure to be in photo-albums directory cd photo-albums\n Run amplify init\n Press Enter to accept the default project name \u0026lsquo;photo-albums\u0026rsquo;\n Enter \u0026lsquo;dev\u0026rsquo; for the environment name\n Select \u0026lsquo;None\u0026rsquo; for the default editor (we\u0026rsquo;re using Cloud9)\n Choose JavaScript and React when prompted\n Accept the default values for paths and build commands\n Select the default profile when prompted\n  This will create a new local configuration for us which we can use to set up an [Amazon Cognito](https://aws.amazon.com/cognito/) User Pool to act as the backend for letting users sign up and sign in. (More about Amazon Cognito and what a User Pool is below.) If you want to read more about this step, take a look at the 'Installation and Configuration' steps from the [AWS Amplify Authentication guide](https://aws-amplify.github.io/amplify-js/media/authentication_guide.html).  Adding authentication  Run amplify add auth to add authentication to the app\n Select Yes when asked if you\u0026rsquo;d like to use the default authentication and security configuration\n Run amplify push to create these changes in the cloud\n Wait for the provisioning to complete. This will take a few minutes.\n  The Amplify CLI will take care of provisioning the appropriate cloud resources and it will update src/aws-exports.js with all of the configuration data we need to be able to use the cloud resources in our app.  Congratulations! You\u0026rsquo;ve just created a serverless backend for user registration and authorization capable of scaling to millions of users with Amazon Cognito.\nAmazon Cognito lets you add user sign-up, sign-in, and access control to your web and mobile apps quickly and easily. We just made a User Pool, which is a secure user directory that will let our users sign in with the username and password pair they create during registration. Amazon Cognito (and the Amplify CLI) also supports configuring sign-in with social identity providers, such as Facebook, Google, and Amazon, and enterprise identity providers via SAML 2.0. If you'd like to learn more, we have a lot more information on the [Amazon Cognito Developer Resources page](https://aws.amazon.com/cognito/dev-resources/) as well as the [AWS Amplify Authentication documentation.](https://aws-amplify.github.io/amplify-js/media/authentication_guide#federated-identities-social-sign-in)  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/10_what_we_will_build.html",
	"title": "What We&#39;ll Build",
	"tags": [],
	"description": "",
	"content": " Our Goal In this workshop, we\u0026rsquo;ll build an app with quite a few features, including:\n Allowing user sign up and authentication, so we know who owns which photo albums\n Building an API server, so our front end has a way to load the appropriate albums and photos to show a given user\n Storing data about albums, photos, and permissions of who can view what, so that our API has a fast and reliable place to query and save data to\n Storing and serving photos, so we have a place to put all of the photos that users are uploading to albums\n Automatically creating photo thumbnails, so we don\u0026rsquo;t need to deliver full-resolution photos when users browse a photo album\u0026rsquo;s list of photos\n Automatically detecting relevant labels for each uploaded photo and making photos searchable based on these labels\n  The Architecture Here\u0026rsquo;s a map of the services we\u0026rsquo;ll use and how they\u0026rsquo;ll all connect.\nOur Tools If we were to try and build scalable and highly-available systems to handle each of the above concerns on our own, we\u0026rsquo;d probably never get around to building our app! Fortunately, AWS provides services and tooling to handle a lot of the undifferentiated heavy lifting involved in building modern, robust applications. We\u0026rsquo;ll use a number of these services and tools in our solution, including:\n The AWS Amplify CLI, to rapidly provision and configure our cloud services\n The AWS Amplify JavaScript library, to connect our front end to cloud resources\n Amazon Cognito, to handle user sign up authorization\n Amazon Simple Storage Service (S3), to store and serve as many photos as our users care to upload, and to host the static assets for our app\n Amazon DynamoDB, to provide millisecond response times to API queries for album and photo data\n AWS AppSync, to host a GraphQL API for our front end\n AWS Lambda, to create photo thumbnails asynchronously in the cloud\n Amazon Rekognition, to detect relevant labels for uploaded photos\n Amazon Elasticsearch Service, to index and search our photos by their labels\n  If any or all of these services are new to you, don\u0026rsquo;t worry. We\u0026rsquo;ll cover everything you need to know to get started using everything mentioned above. And there\u0026rsquo;s no better way to learn than to build, so let\u0026rsquo;s get started!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84.html",
	"title": "사전준비",
	"tags": [],
	"description": "",
	"content": " Workshop 사전 준비  AWS account 생성하기   Cloud9 Workspace 생성하기   설치 \u0026amp; 설정   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/20_album_membership.html",
	"title": "Allowing Other Users To Collaborate In Albums",
	"tags": [],
	"description": "",
	"content": " We can take advantage of the fact that multiple users can sign in to our app and add the ability for other people view and upload to our albums on a case-by-case basis.\nThe simplest way to do this is to have each album contain a set of usernames that are allowed to view and upload photos to it. Let\u0026rsquo;s see how we can make this work.\nUpdating the backend Amplify supports multiple authorization declarations on the @model types in our GraphQL Schema. We can add a second auth rule, stating that any user who\u0026rsquo;s username is in an Album\u0026rsquo;s members field can see (but not edit) the record.\n Replace /photo-albums/amplify/backend/api/photoalbums/schema.graphql with the following: # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [ { allow: owner } { allow: owner, ownerField: \u0026#34;members\u0026#34;, queries: [get, list], mutations: null } ]) {  id: ID! name: String! owner: String members: [String] photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! } \n Run amplify push to regenerate a new GraphQL schema and update our AppSync API.\n  You can learn more about adding multiple ownership rules to a model in [the GraphQL Transform documentation](https://aws-amplify.github.io/docs/cli/graphql?sdk=js).  Updating the frontend Now that our backend has been updated to look for a list of usernames in a members field on our album records, all we need to do is update our UI to allow an album\u0026rsquo;s owner to manage the usernames that should be considered members of the album. We\u0026rsquo;ll also add in another AppSync subscription so that our listing of usernames will refresh when a new username is added to an album.\nReplace photo-albums/src/App.js with the following updated version: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Icon, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, Auth, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const SubscribeToUpdatedAlbums = ` subscription OnUpdateAlbum { onUpdateAlbum { id name owner members } } `;  const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name owner members photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); } photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); const subscription = API.graphql(graphqlOperation(SubscribeToUpdatedAlbums)).subscribe({ next: (update) =\u0026gt; { const album = update.value.data.onUpdateAlbum; this.setState({ album: Object.assign(this.state.album, album) }) } }); this.setState({ albumUpdatesSubscription: subscription }) } componentWillUnmount() { this.state.albumUpdatesSubscription.unsubscribe(); }  render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } } class AlbumDetails extends Component { async componentDidMount() { this.setState({ currentUser: await Auth.currentAuthenticatedUser() }); }  render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; { this.state.currentUser.username === this.props.album.owner \u0026amp;\u0026amp; \u0026lt;Segment.Group\u0026gt; \u0026lt;Segment\u0026gt; \u0026lt;AlbumMembers members={this.props.album.members} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;Segment basic\u0026gt; \u0026lt;AddUsernameToAlbum albumId={this.props.album.id} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;/Segment.Group\u0026gt; }  \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AddUsernameToAlbum extends Component { constructor(props) { super(props); this.state = { username: \u0026#39;\u0026#39; }; } handleChange = (e, { name, value }) =\u0026gt; this.setState({ [name]: value }) handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.albumId})); let updatedAlbum = data.getAlbum; const updatedMembers = (data.getAlbum.members || []).concat([this.state.username]); updatedAlbum.members = updatedMembers; const {id, name, owner, members} = updatedAlbum; const updatedAlbumInput = {id, name, owner, members}; const UpdateAlbum = `mutation UpdateAlbum($input: UpdateAlbumInput!) { updateAlbum(input: $input) { id members } } `; const result = await API.graphql(graphqlOperation(UpdateAlbum, { input: updatedAlbumInput })); console.log(`Added ${this.state.username}to album id ${result.data.updateAlbum.id}`); this.setState({ username: \u0026#39;\u0026#39; }); } render() { return ( \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Username\u0026#39; icon=\u0026#39;user plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Add\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;username\u0026#39; value={this.state.username} onChange={this.handleChange} /\u0026gt; ) } } const AlbumMembers = (props) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h4\u0026#39;\u0026gt; \u0026lt;Icon name=\u0026#39;user circle\u0026#39; /\u0026gt; \u0026lt;Header.Content\u0026gt;Members\u0026lt;/Header.Content\u0026gt; \u0026lt;/Header\u0026gt; { props.members ? \u0026lt;List bulleted\u0026gt; {props.members \u0026amp;\u0026amp; props.members.map((member) =\u0026gt; \u0026lt;List.Item key={member}\u0026gt;{member}\u0026lt;/List.Item\u0026gt;)} \u0026lt;/List\u0026gt; : \u0026#39;No members yet (besides you). Invite someone below!\u0026#39; } \u0026lt;/div\u0026gt; );  class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported Icon from semantic-ui-react and Auth from aws-amplify\n Added SubscribeToUpdatedAlbums query\n Added owner and member fields to be fetched by the GetAlbum query\n Subscribed to album updates inside the AlbumDetailsLoader component in order to trigger a re-rendering of the album when new members are added\n Updated the AlbumDetails component\u0026rsquo;s render() method to include UI for managing members\n Created AddUsernameToAlbum and AlbumMembers components to handle adding and listing album members and only render these components if the user owns the album\n  Try out the app To test out our new multi-user capabilities, we\u0026rsquo;ll need at least one other user to invite to an album.\n Sign out of the app and create a new user (don\u0026rsquo;t forget to check for the verification email and submit the verification code).\n Sign out of the new username and back in using your original username.\n Navigate to an album you\u0026rsquo;d like to share and invite your new username to the album.\n Sign out and then back in with the new username and you\u0026rsquo;ll see the album listed! You should also notice that the album membership controls aren\u0026rsquo;t visible since this user doesn\u0026rsquo;t own the album.\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/20_bootstrapping_the_app.html",
	"title": "Bootstrapping the App",
	"tags": [],
	"description": "",
	"content": " Creating a React app We\u0026rsquo;ll get things started by building a new React web app using the create-react-app CLI tool.\nThis will give us a sample React app with a local auto-reloading web server and some helpful transpiling support for the browser like letting us use async/await keywords, arrow functions, and more.  You can learn more about create-react-app at [https://github.com/facebook/create-react-app](https://github.com/facebook/create-react-app).  In the Cloud9 terminal, run npx create-react-app photo-albums, then navigate to the newly created directory cd photo-albums\nAdding Semantic UI React Before we start writing our UI, we\u0026rsquo;ll also include Semantic UI components for React to give us components that will help make our interface look a bit nicer.\nIn the photo-albums directory, run npm install --save semantic-ui-react\nThen, edit public/index.html and add this stylesheet link:\n\u0026lt;head\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.3.3/semantic.min.css\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/head\u0026gt; Starting the App Now let\u0026rsquo;s start our development server so we can make changes and see them refreshed live in the browser.\nIn the photo-albums directory, run npm start.\nOnce the web server has started, click the Preview menu and select Preview Running Application\nIf you\u0026rsquo;d like, you can also pop the preview to a new window:\nFinally, open another terminal window. We\u0026rsquo;ll leave this first terminal alone since it\u0026rsquo;s running the web server process.\nSimplifying markup Next, we\u0026rsquo;ll want to start with a clean slate.\nEdit src/App.js and change it to display a simple \u0026lsquo;Hello World\u0026rsquo; message. Replace the existing content of the file with:\n// src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default App; At this point, the browser should automatically refresh and show a much simpler page, with just some text that says 'Hello World'. It's not much to look at yet, but it's good to start with as little markup as possible.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/20_cleanup.html",
	"title": "Cleaning Up",
	"tags": [],
	"description": "",
	"content": " Deleting via Amplify Amplify can do a pretty good job of removing most of the cloud resources we\u0026rsquo;ve provisioned for this workshop (just by attempting to delete the CloudFormation nested stack it provisioned). However, it will refuse to delete a few items, which we\u0026rsquo;ll manually take care of as well.\n From the photo-albums directory, run: amplify delete and press Enter to confirm the deletion.\n Wait a few minutes while Amplify deletes most of our resources.\n  A small bit of manual cleanup At this point, if you open the CloudFormation stacks console and click on the various stacks that show a status of \u0026lsquo;DELETE FAILED\u0026rsquo;, you can see what failed to delete and why.\nThe Authenticated users IAM role failed to delete because it won\u0026rsquo;t delete while there were still policies associated with it when CloudFormation tried to delete it. However, at this point, all the policies should now be deleted, so another attempt at deleting the stack should succeed.\n Select our stack that failed to delete\n Click Actions\n Select Delete Stack\n Leave the Auth Role un-checked and click Yes, Delete\n Wait a moment and see if the delete succeeds. If not, you can always go to the IAM Roles console, search for the role (it will start with \u0026lsquo;photoalbums\u0026rsquo;), then select and delete it.\n  The S3 Buckets that Amplify created will not be automatically deleted. To delete these buckets:\n Open the S3 console\n Click the Date created column to sort the buckets with the newest ones on top\n For each photoalbums* bucket, click it\u0026rsquo;s row (not the name itself), click the Delete bucket button, then copy/paste the bucket name to confirm the deletion.\n  Deleting the Cloud9 Workspace  Go to your Cloud9 Environment\n Select the environment named workshop and pick Delete\n Type the phrase \u0026lsquo;Delete\u0026rsquo; into the confirmation box and click Delete\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/20_connecting_the_lambda_to_the_bucket.html",
	"title": "Connecting the photos bucket to the processor function",
	"tags": [],
	"description": "",
	"content": " Triggering the function when new photos are uploaded to the S3 bucket Now that we\u0026rsquo;ve created our Photo Processor function, we need to set up a trigger for it to run. Since we want to process every photo that gets uploaded to an album, we\u0026rsquo;ll make these changes by updating the configuration of the S3 userfiles bucket that Amplify created for us.\n Replace photo-albums/amplify/backend/storage/photoalbumsstorage/s3-cloudformation-template.json with the following: { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;S3 resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;bucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }  }, \u0026#34;Conditions\u0026#34;: { \u0026#34;ShouldNotCreateEnvResources\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; }, \u0026#34;NONE\u0026#34; ] }, \u0026#34;EnableUnauthReadWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;rw\u0026#34; ] }, \u0026#34;EnableUnauthRead\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;r\u0026#34; ] }, \u0026#34;EnableUnauthWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;w\u0026#34; ] }, \u0026#34;EnableAuthReadWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;rw\u0026#34; ] }, \u0026#34;EnableAuthRead\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;r\u0026#34; ] }, \u0026#34;EnableAuthWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;w\u0026#34; ] } }, \u0026#34;Resources\u0026#34;: { \u0026#34;InvokePhotoProcessorLambda\u0026#34;: { \u0026#34;Type\u0026#34; : \u0026#34;AWS::Lambda::Permission\u0026#34;, \u0026#34;Properties\u0026#34; : { \u0026#34;Action\u0026#34; : \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;FunctionName\u0026#34; : \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;Principal\u0026#34; : \u0026#34;s3.amazonaws.com\u0026#34;, \u0026#34;SourceAccount\u0026#34; : { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;SourceArn\u0026#34;: \u0026#34;arn:aws:s3:::REPLACE_WITH_USERFILES_BUCKET_NAME\u0026#34; } }, \t\u0026#34;S3Bucket\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::S3::Bucket\u0026#34;, \u0026#34;DeletionPolicy\u0026#34; : \u0026#34;Retain\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Fn::If\u0026#34;: [ \u0026#34;ShouldNotCreateEnvResources\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, \u0026#34;-\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; } ] ] } ] }, \u0026#34;CorsConfiguration\u0026#34;: { \u0026#34;CorsRules\u0026#34;: [ { \u0026#34;AllowedHeaders\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;AllowedMethods\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;HEAD\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34; ], \u0026#34;AllowedOrigins\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;ExposedHeaders\u0026#34;: [ \u0026#34;x-amz-server-side-encryption\u0026#34;, \u0026#34;x-amz-request-id\u0026#34;, \u0026#34;x-amz-id-2\u0026#34; ], \u0026#34;Id\u0026#34;: \u0026#34;S3CORSRuleId1\u0026#34;, \u0026#34;MaxAge\u0026#34;: \u0026#34;3000\u0026#34; } ] }, \u0026#34;NotificationConfiguration\u0026#34;: { \u0026#34;LambdaConfigurations\u0026#34;: [ { \u0026#34;Function\u0026#34;: { \u0026#34;Fn::Join\u0026#34;: [\u0026#34;:\u0026#34;, [ \u0026#34;arn:aws:lambda\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;function\u0026#34;, \u0026#34;workshopphotoprocessor\u0026#34; ] ] }, \u0026#34;Event\u0026#34;: \u0026#34;s3:ObjectCreated:Put\u0026#34;, \u0026#34;Filter\u0026#34;: { \u0026#34;S3Key\u0026#34;: { \u0026#34;Rules\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;prefix\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;uploads/\u0026#34; } ] } } } ] } \t} }, \u0026#34;DenyListS3Buckets\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;DenyListS3Buckets\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [\u0026#34;*\u0026#34;] } ] } } }, \t\u0026#34;S3UnauthPolicyRW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthReadWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } } ] } } }, \u0026#34;S3UnauthPolicyR\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthRead\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3UnauthPolicyW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthPolicyRW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthReadWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] } } } ] } } }, \u0026#34;S3AuthPolicyR\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthRead\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthPolicyW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] } } } ] } } } }, \u0026#34;Outputs\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;Description\u0026#34;: \u0026#34;Bucket name for the S3 bucket\u0026#34; }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n After you paste the new template shown above, find the text **REPLACE_WITH_USERFILES_BUCKET_NAME** in your pasted template and replace it with the name of your userfiles S3 bucket.   You can find this value in **photo-albums/src/aws-exports.js** under the **aws_user_files_s3_bucket** key.  From the photo-albums directory, run: amplify push to update our storage configuration.\n Wait for the update to complete. This step usually only takes a minute or two.\n  What we changed in amplify/\u0026hellip;/s3-cloudformation-template.json  Added a env parameter, allowing Amplify to pass in the current Amplify environment name to the template\n Added a InvokePhotoProcessorLambda resource, giving the S3Bucket permission to invoke the PhotoProcessor lambda function.\n Added a NotificationConfiguration property to the S3Bucket resource, configuring the bucket to invoke our PhotoProcessor lambda function when new photos are added to the \u0026lsquo;uploads/\u0026rsquo; prefix\n Added a DenyListS3Buckets IAM policy, preventing authenticated users from listing the contents of any buckets on S3\n  The default permissions for the user files S3 storage bucket set up by the Amplify CLI allows anyone logged in to our app to list the contents of the bucket for any keys that start with 'public/' (and a few other prefixes too). While our app doesn't expose this as an interaction, someone poking around might try to take their credentials from our app and make an API call to S3 directly to try and list the bucket where all the photos are going.   We have no need to let users list bucket contents at all, so we've added an IAM policy to the role used by authenticated users to explicitly deny users the ability to list any S3 bucket contents.   Now, nobody will be able to go directly to the S3 API and list all of the photos that our users have uploaded. We're using UUIDs for album and photo IDs, so we shouldn't have to worry about a curious user enumerating through patterns of IDs hoping to find photos to view.  Try uploading another photo With these changes completed, we should be able to upload a photo and see our Photo Processor function execute automatically. Try uploading a photo to an album, wait a moment, then refresh the page to see if the album renders the newly uploaded photo. If you see a photo, it means that our Photo Processor function was automatically triggered by the upload, it created a thumbnail, and it added all of the photo information to the DynamoDB table that our AppSync API reads from for resolving Photos.\nRefreshing the album view in order to see new photos isn’t a great user experience, but this workshop has a lot of material already and there’s still more to cover in the next section, too. In short, one way to handle this with another AppSync subscription would be to have our photo processor Lambda function trigger a mutation on our AppSync API, and to have the AlbumDetailsLoader component subscribe to that mutation. However, because we’re using Amazon Cognito User Pool authentication for our AppSync API, the only way to have our Lambda function trigger such a mutation would be to create a sort of ‘system’ user (through the normal user sign up and confirmation process), store that user’s credentials securely (perhaps in AWS Secrets Manager), and authenticate to our AppSync API as that user inside our Lambda in order to trigger the mutation. For simplicity\u0026rsquo;s sake, we\u0026rsquo;ll stick to just refreshing the album view for this workshop.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started.html",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started  What We\u0026#39;ll Build   Bootstrapping the App   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/20_prep_for_searching.html",
	"title": "Making Photos Searchable",
	"tags": [],
	"description": "",
	"content": " Updating the GraphQL Schema Now that we are storing labels for each photo, we\u0026rsquo;re ready to move on and expose this data via our AppSync API.\nWhile it\u0026rsquo;s possible to perform some level of searching via DynamoDB Query operations, a more flexible and performant approach is to use the Amazon Elasticsearch Service to index data and handle our search queries. Fortunately, the Amplify CLI makes creating an Amazon Elasticsearch Service endpoint, and connecting it to our app\u0026rsquo;s data, very easy.\n Replace /photo-albums/amplify/backend/api/photoalbums/schema.graphql with the following: # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable {  id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! }\n From the photo-albums directory, run: amplify push to provision our new resources.\n Wait for the update to finish. Creating a new Amazon Elasticsearch Service endpoint can take several minutes. This step usually takes 8 to 12 minutes to complete.\n  You can learn more about Amplify's *@searchable* GraphQL directive in [Amplify's GraphQL Transform documentation](https://aws-amplify.github.io/docs/cli/graphql?sdk=js).  What we changed  Added the @searchable directive to the Photo type, which will have Amplify connect Photo data to an Amazon Elasticsearch Service cluster\n Added a new labels propery to the Photo type so that the labels information added by the Photo Processor function will also be streamed as part of each Photo record into the Elasticsearch Service for us to search on\n  You can continue on to the next section while you're waiting for the `amplify push` to complete.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/20_adding_auth_front.html",
	"title": "Rendering the Front End",
	"tags": [],
	"description": "",
	"content": " Now that we have our backend set up for managing registrations and sign-in, all we need to do is use the withAuthenticator higher-order React component from AWS Amplify to wrap our existing App component. This will take care of rendering a simple UI for letting users sign up, confirm their account, sign in, sign out, or reset their password.\nAdding Amplify NPM dependencies We haven\u0026rsquo;t yet added the aws-amplify and aws-amplify-react modules to our app, so let\u0026rsquo;s add them.\n Run npm install --save aws-amplify aws-amplify-react\n Replace the contents of src/App.js with the following: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; import Amplify from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; import { withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; Amplify.configure(aws_exports);  class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true});\n  Take a look at the web app now and you should have a sign-up / sign-in form!\nWhat we changed in App.js  Imported and configured the AWS Amplify JS library\n Imported the withAuthenticator higher order component from aws-amplify-react\n Wrapped the App component using withAuthenticator\n  Creating an account Create an account in the app by providing a username, password, and a valid email address (to receive a confirmation code at).\nYou'll be taken to a screen asking you to confirm a code. This is because Amazon Cognito wants to verify a user's email address before it lets them sign in.  Check your email. You should have received a confirmation code message. Copy and paste the confirmation code into your app and you should then be able to log in with the username and password you entered during sign up.\nOnce you sign in, the form disappears and you can see our App component rendered below a header bar that contains your username and a \u0026lsquo;Sign Out\u0026rsquo; button.\nThis is a pretty simple authentication UI, but there's a lot you can do to customize it, including replacing parts with your own React components or using a completely hosted UI that can redirect back to your app. See the Customization section of the [AWS Amplify Authentication Guide](https://aws.github.io/aws-amplify/media/authentication_guide#customization) for more information.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/20_trying_out_queries.html",
	"title": "Trying Out Some Queries",
	"tags": [],
	"description": "",
	"content": " Open the AWS Console and click into the photoalbums API. Now we can start poking around with the API.\n Link to AWS AppSync web console in Northern Virgina\n Link to AWS AppSync web console in Ireland\n \nClick Queries in the sidebar on the left.\nThis area is AWS AppSync's interactive query explorer. We can write queries and mutations here, execute them, and see the results. It's a great way to test things out to make sure our resolvers are working the way we expect.  Authenticating to AppSync Before we can issue queries, we'll need to authenticate (because our AppSync API is configured to authenticate users via the Amazon Cognito User Pool we set up when we configured the authentication for our app.   Click the Login with User Pools button at the top of the query editor.\n Look up the value for the ClientId field\n In Cloud9, open photo-albums/src/aws-exports.js Copy the value of the aws_user_pools_web_client_id property  Paste the value into the ClientId field\n Enter your credentials for the user you created when we added authentication\n Click Login\n  Trying out some queries You should now be able to try out the following mutations and queries. Press the orange \u0026lsquo;play\u0026rsquo; button to execute queries and mutations.\nAdd a new album by copy/pasting the following and running the query:\nmutation { createAlbum(input:{name:\u0026quot;First Album\u0026quot;}) { id name } }  Add another album by editing and re-running your createAlbum mutation with another album name:\nmutation { createAlbum(input:{name:\u0026quot;Second Album\u0026quot;}) { id name } }  List all albums by running this query:\nquery { listAlbums { items { id name } } }  As you can see, we\u0026rsquo;re able to read and write data through GraphQL queries and mutations and AppSync takes care of reading and persisting data (in this case, to DynamoDB).\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/20_software.html",
	"title": "설치 &amp; 설정",
	"tags": [],
	"description": "",
	"content": " 코딩을 시작하기 전에, Cloud9 환경에 몇 가지 설치, 업데이트, 설정을 해야합니다.\n설치와 업데이트 Cloud9 터미널에서 다음 명령어를 수행하세요. 우리가 사용할 몇 가지 소프트웨어를 설치하고 업데이트 합니다.\n# Update the AWS CLI pip install --user --upgrade awscli # Install and use Node.js v8.10 (to match AWS Lambda) nvm install v8.10.0 nvm alias default v8.10.0 # Install the AWS Amplify CLI npm install -g @aws-amplify/cli 이 명령어들은 완료 되는데 시간이 좀 걸릴수 있습니다. (few minutes)  기본 region 설정하기 가장 좋은 방법은 인프라를 고객과 가까운 지역에 구성하는 것입니다. (Amplify는 아직 서울 리전을 지원하지 않습니다.)\n이번 워크샵에서는 기본 AWS region을 다음 지역으로 설정합니다:\n- 미국 - Northern Virginia (us-east-1)\n- 유럽 - Ireland (eu-west-1)\nAWS config file 생성하기, 실행:\n cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=us-east-1 END  cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=eu-west-1 END  \nAWS Amplify CLI는 모바일과 웹 어플리케이션을 개발을 심플하게 해주는 강력한 기능들을 제공하는 툴체인 입니다. 위의 단계에서는 설치만 진행했기 때문에 설정 단계가 추가적으로 필요합니다. AWS Amplify CLI는 **~/.aws/config**을 찾아 작업할 Region 정보를 판별합니다. Cloud9은 유효한 Administrator credentials이 **~/.aws/credentials** 파일안에 있는지 확인만 할 뿐 **~/.aws/config**을 생성하지 않습니다.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth.html",
	"title": "Adding Authentication",
	"tags": [],
	"description": "",
	"content": " Adding Authentication  Setting Up the Back End   Rendering the Front End   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/30_adding_storage.html",
	"title": "Adding Cloud Storage",
	"tags": [],
	"description": "",
	"content": " We\u0026rsquo;ll need a place to store all of the photos that get uploaded to our albums. Amazon Simple Storage Service (S3) is a great option for this and Amplify\u0026rsquo;s Storage module makes setting up and working with S3 very easy.\nYou can read more about Amplify's Storage module [here](https://aws-amplify.github.io/amplify-js/media/storage_guide).  Configuring and adding storage First, we\u0026rsquo;ll use the Amplify CLI to enable storage for our app. This will create a bucket on Amazon S3 and set it up with appropriate permissions so that users who are logged in to our app can read from and write to it.\n From the photo-albums directory, run amplify add storage\n Select \u0026lsquo;Content\u0026rsquo; at the prompt\n Enter values or accept defaults for the resource category and bucket name\n Configure it so that only authenticated users have access with read/write permissions.\nHere is sample output with responses:\n$ amplify add storage ? Please select from one of the below mentioned services: Content (Images, audio, video, etc.) ? Please provide a friendly name for your resource that will be used to label this category in the project: photoalbumsstorage ? Please provide bucket name: \u0026lt;accept the default value\u0026gt; ? Who should have access: Auth users only ? What kind of access do you want for Authenticated users: read/write  Now we\u0026rsquo;ll have Amplify modify our cloud environment, provisioning the storage resources we just added.\n Run amplify push Press Enter to confirm the changes Wait for the provisioning to finish. Adding storage usually only takes a minute or two.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql.html",
	"title": "Creating a GraphQL API",
	"tags": [],
	"description": "",
	"content": " Creating a GraphQL API  Setting Up AppSync   Trying Out Some Queries   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/40_upload_photos_consolidated.html",
	"title": "Managing Photos",
	"tags": [],
	"description": "",
	"content": " Now that we have an S3 bucket where our photos can get stored, we\u0026rsquo;ll want to create a UI that lets us upload photos to that bucket for storage. We\u0026rsquo;ll also need to track that the photo was intended to be part of a specific album that it was uploaded to, so that we can eventually load all of the photos that belong to that album.\nLet\u0026rsquo;s create a new S3ImageUpload component that will contain an HTML file input element which will fire off an event handler when a user selects a photo.\nOur upload event handler will need to upload the file to S3 with some metadata annotating which album it's destined for. Luckily, the [Amplify JS Storage module](https://aws-amplify.github.io/amplify-js/media/storage_guide) makes uploading files to S3 very easy. Also, we'll need to introduce one new dependency to our app — a way to generate UUIDs — because we'll need to ensure that we're uploading files to S3 with unique names (if we used the filenames from users' devices, they could conflict).  From the photo-albums directory, run npm install --save uuid\nNow we\u0026rsquo;ll update our app by adding some imports, creating an S3ImageUpload component, and including the S3ImageUpload component in the AlbumDetails component.\nReplace photo-albums/src/App.js with this updated version: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } } `; class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } }  class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; }  \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported v4 as uuid from uuid\n Imported Divider and Form from semantic-ui-react\n Imported Storage from aws-amplify\n Imported S3Image from aws-amplify-react\n Updated GetAlbum query to support paginating photos\n Created new components: S3ImageUpload and PhotosList\n Updated AlbumDetailsLoader to support paginating photos\n Added PhotosList to AlbumDetails\u0026rsquo;s render output\n  Try uploading a photo At this point there\u0026rsquo;s not much to look at, but you should be able to click the button, select a file, and see it change to \u0026lsquo;Uploading…\u0026rsquo; before switching back to an upload button again.\nYou can also go manually explore the S3 bucket in the AWS web console to see that the files are getting uploaded. The easiest way to find the bucket name is to look at _src/aws-exports.js_ and find the value configured for __aws_user_files_s3_bucket__. Find your bucket in the S3 web console, then look in the bucket under _public/uploads_.  There are a few things worth calling out in our new _S3ImageUpload_ component. It uses AWS Amplify's _Storage.put_ method to upload a file into the S3 bucket we configured for our app. In this API call, we're passing in a few extra options.  We pass in _customPrefix: { public: 'uploads/' }_ because we'll want to automatically make thumbnails for each image. We'll accomplish this shortly by adding a trigger onto the S3 bucket that will fire off a thumbnail creation function for us each time any file is added to the _uploads/_ path of the bucket. New thumbnails will also get added to the bucket and to avoid a recursive trigger loop where each thumbnail creation then causes the function to fire again, we'll scope our trigger to only execute for files that are added with a key prefix of _uploads/_. Amplify knows to use our prefix because we specified that it was for files that should be publicly accessible, which is the default permission level for Storage.put.  Is it a problem that the default is for all files to be accessible (at the API level) to any of our users in the app? No. This is acceptable since we're using unguessable UUIDs for the photo keys, and users will only be able to retrieve a list of photos for an album if they know that album's UUID as well. If you go read all of the Amplify Storage module's API (or if you're familiar with the underlying S3 API), you might ask “but wait, users can just list all of the objects in the public path and see all of the photos!” For now, you're right, but we'll deal with that later, after our app is working and we take additional precautions to lock it down further (by restricting album listing to certain usernames and by preventing users from listing items in the bucket).  We pass in metadata: _{ albumid: this.props.albumId }_ because we're going to have an S3 thumbnail trigger function take care of adding the information about this photo to our data store after it finishes making the thumbnail, and that function will somehow need to know what album the photo was uploaded for. We could have put the album ID in the photo key as a prefix or suffix, for example, but the metadata approach feels more appropriate. After all, this *is* metadata about the photo, right?  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/40_searching_for_labels.html",
	"title": "Searching Photos By Label",
	"tags": [],
	"description": "",
	"content": " With all of the back-end work completed, now we just need to update our web app to allow searching for photos by label.\nLet\u0026rsquo;s create a new Search component and add it to the App component to be rendered on the root path. For rendering all of the matching photos in the Search component, we\u0026rsquo;ll re-use the PhotosList component we already created.\nReplace photo-albums/src/App.js with the following: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } }  class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt;  \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed  Added a SearchPhotos query to find photos for a given label.\n Added a Search component that uses the SearchPhotos query to get a list of matching photos for a given label and renders the photos using the pre-existing PhotosList component.\n Added the SearchPhotos component to render as part of the root \u0026lsquo;/\u0026rsquo; path.\n  Testing the photos search With that done, you should be able to go back to the root path \u0026lsquo;/\u0026rsquo; in the web app and try out the search.\nNote that when Amplify sets up the Amazon Elasticsearch Service integration, it will only index new data because it doesn\u0026rsquo;t pass the existing data from DynamoDB at the time of creation. You\u0026rsquo;ll need to upload a few more photos to an album before you\u0026rsquo;ll see search results.\nGive it a shot!\nBefore trying to search for a photo, please make sure that the `amplify push` from the previous page has finished.   To test out the photo search, look in the Photos table in DynamoDB for some valid labels to use as search terms. You must enter a label that matches exactly with one that was detected by Rekognition.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums.html",
	"title": "Working With Albums",
	"tags": [],
	"description": "",
	"content": " Working With Albums  Managing Albums   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos.html",
	"title": "Managing Photos",
	"tags": [],
	"description": "",
	"content": " Managing Photos  Adding Cloud Storage   Managing Photos   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails.html",
	"title": "Generating Thumbnails",
	"tags": [],
	"description": "",
	"content": " Generating Thumbnails  Creating a Photo Processor Lambda function   Connecting the photos bucket to the processor function   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai.html",
	"title": "Adding AI",
	"tags": [],
	"description": "",
	"content": " Adding AI  Integrating Amazon Rekognition   Making Photos Searchable   Searching Photos By Label   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying/10_deploying.html",
	"title": "Deploying our app to S3",
	"tags": [],
	"description": "",
	"content": "Before we build and publish our app, we should free up some memory on the Cloud9 instance. If you\u0026rsquo;re using a micro Cloud9 instance size, there\u0026rsquo;s a good chance there won\u0026rsquo;t be enough memory available to keep our development web server running and to create a production build.\n Go to the terminal tab that\u0026rsquo;s running the development webserver (where you ran npm start)\n Press Control-C to interrupt the development webserver and kill it.\n  The AWS Amplify CLI makes it easy to deploy our app to a publicly accessible bucket on S3.\n Run amplify hosting add, select a deployment mode (for this workshop, select \u0026lsquo;Development\u0026rsquo;), and respond to the questions (you can accept the default value of index.html for the index and error doc).\n$ amplify hosting add ? Select the environment setup: DEV (S3 only with HTTP) ? hosting bucket name photoalbums-19700101010203--hostingbucket ? index doc for the website index.html ? error doc for the website index.html Run amplify push\n Wait for the new S3 bucket that will serve our app\u0026rsquo;s static content is created. This usually takes about a minute.\n Run amplify publish\n Wait while Amplify builds a production version of our app and deploys it to the hosting bucket. This process usually takes a minute or two.\n  After the build and deploy finishes, you\u0026rsquo;ll see a URL for the version of deployed app. Any time you make new changes to the app, just re-run amplify publish whenever you want to push a new build out.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying.html",
	"title": "Publishing Our App",
	"tags": [],
	"description": "",
	"content": " Publishing Our App  Deploying our app to S3   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up.html",
	"title": "Wrapping Up",
	"tags": [],
	"description": "",
	"content": " Wrapping Up  Congratulations!   Cleaning Up   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus.html",
	"title": "Bonus Content",
	"tags": [],
	"description": "",
	"content": " Bonus Content  Making a Lightbox for Viewing Fullsize Photos   Allowing Other Users To Collaborate In Albums   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]