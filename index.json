[
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/1_account.html",
	"title": "AWS account 생성하기",
	"tags": [],
	"description": "",
	"content": "Workshop에서 사용하고자 하는 AWS 계정은 새로운 IAM 역할을 만들수 있어야 하고 다른 IAM 권한 범위를 지정할 수 있어야 합니다.  이미 AWS 계정을 가지고 있고, IAM 관리자 접속 권한이 있다면 이 페이지를 넘어가도 좋습니다.   관리자 접속 권한 계정이 없다면: 새로 하나 만듭시다.\n AWS 계정을 가지게 되었다면, 남은 워크샵 단계를 잘 따르고 있는 확인해보세요.\nAWS 계정에 대한 관리자 권한이 있는 IAM user : 워크샵에서 사용할 IAM user를 만듭니다.\n 사용자 상세정보를 입력합니다:  AdministratorAccess IAM 정책 연결:  create the new user 클릭:  Take note of the login URL and save:   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/",
	"title": "Amplify Web App Workshop",
	"tags": [],
	"description": "",
	"content": " AWS Amplify와 AWS AppSync로  사진 공유 웹 어플리케이션 구현 환영합니다! 이번 워크샵에서 React를 사용하여 사용자들이 사진을 업로드하고 공유하는 data-driven 기반의 안전한 사진 갤러리 웹 어플리케이션을 구현합니다. AWS AppSync를 이용하여 Amazon DynamoDB에 백업된 데이터를 GraphQL API를 통하여 빠르게 가져오고 실행합니다. AWS Amplify 라이브러리를 사용하여 사용자를 인증하고, API와 통신하며, 사진 업로드 관리를 어떻게 하는지 시연합니다. 마지막으로 Amazon Rekognition으로 AI 기반 오브젝트 태그를 추가하여 사용자가 수동으로 검색 데이터 입력하지 않아도 사진을 찾아주도록 구현합니다. "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums/5_managing_albums.html",
	"title": "Managing Albums",
	"tags": [],
	"description": "",
	"content": " At this point, we have a web app that authenticates users and a secure GraphQL API endpoint that lets us create and read Album data. It\u0026rsquo;s time to connect the two together!\nAs we saw above, [AWS Amplify](https://aws.github.io/aws-amplify/) is an open source JavaScript library that makes it very easy to integrate a number of cloud services into your web or React Native apps. We'll start by using its [Connect React component](https://aws-amplify.github.io/docs/js/api#connect) to take care of automatically querying our GraphQL API and providing data for our React components to use when rendering.  The Amplify CLI has already taken care of making sure that our *src/aws-exports.js* file contains all of the configuration we'll need to pass to the Amplify JS library in order to talk to the AppSync API. All we'll need to do is add some new code to interact with the API.  Here\u0026rsquo;s what it will look like when we render our list of Albums:\nUpdating our App Let\u0026rsquo;s update our front-end to: - allow users to create albums - show a list of albums - allow users to click into an album to view its details\nFrom the photo-albums directory, run npm install --save react-router-dom to add a new dependency for routing.\nUsually, we'd create separate files for each of our components, but here we'll just keep everything together so we can see all of the front end code in one place.  Replace photo-albums/src/App.js with the following updated version: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;;  import Amplify, { API, graphqlOperation } from \u0026#39;aws-amplify\u0026#39;; import { Connect, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!) { getAlbum(id: $id) { id name } } `; class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { render() { return ( \u0026lt;Connect query={graphqlOperation(GetAlbum, { id: this.props.id })}\u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.getAlbum) return; return \u0026lt;AlbumDetails album={data.getAlbum} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AlbumDetails extends Component { render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;p\u0026gt;TODO: Allow photo uploads\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;TODO: Show photos for this album\u0026lt;/p\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } }  export default withAuthenticator(App, {includeGreetings: true});\nWhat we changed in src/App.js  Imported the Connect component from aws-amplify-react\n Imported more presentational components from semantic-ui-react\n Imported API and graphqlOperation from aws-amplify\n Imported routing components from react-router-dom\n Added makeComparator to allow us to sanely sort strings in JS\n Added new components: NewAlbum, AlbumsList, AlbumsDetailsLoader, AlbumDetails, AlbumsListLoader\n Added GraphQL queries and mutations: ListAlbums, SubscribeToNewAlbums, GetAlbum\n Updated the App component to present different components based on the current URL route\n  Try out the app Check out the app now and try out the new features:\n View the list of albums\n Create a new album and see it appear in the albums list\n Click into an album to see the beginnings of our Album details view\n When viewing an Album, click \u0026lsquo;Back to Albums list\u0026rsquo; to go home\n  The loading magic here comes from [AWS Amplify's *Connect* component](https://aws-amplify.github.io/docs/js/api#connect) (which we imported from the *aws-amplify-react* package). All we need to do is pass this component a GraphQL query operation in its query prop. It takes care of running that query when the component mounts, and it passes information down to a child function via the data, loading, and errors arguments. We use those values to render appropriately, either showing some loading text or passing the successfully fetched data to our *AlbumsList* component.  The *listAlbums* query we're above using passes in a very high limit argument. This is because we can just load all of the albums in one request and sort the albums alphabetically on the client-side (instead of dealing with paginated DynamoDB responses). This keeps the *AlbumsList* code pretty simple, so it's probably worth the trade off in terms of performance or network cost.  Also worth noting is how we're leveraging an AppSync real-time subscription to automatically refresh the list of albums whenever a new album is created.   Our GraphQL schema contains a *Subscription* type with a bunch of subscriptions that were auto-generated back when we had AWS AppSync create the resources (like the DynamoDB table and the AWS AppSync resolvers) for our *Album* type. One of these the _onCreateAlbum_ subscription.   The _subscription_ and _onSubscriptionMsg_ properties on the _Connect_ component tell it to subscribe to the _onCreateAlbum_ event data and update the data for AlbumsList accordingly.   The content for the subscription property looks very similar to what we provided for the query property previously; it just contains a query specifying the subscription we want to listen to and what fields we'd like back when new data arrives. The only slightly tricky bit is that we also need to define a handler function to react to new data from the subscription, and that function needs to return a new set of data that the _Connect_ component will use to refresh our _ListAlbums_ component. This is what we've done above.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/10_setting_up_appsync.html",
	"title": "AppSync 세팅",
	"tags": [],
	"description": "",
	"content": " 이제 인증된 사용자를 가지고 앨범을 만들기 위한 API를 만들어 봅시다. 이 앨범에는 아직 사진이 없고 단순히 이름과 앨범을 생성한 사용자 이름만 있을 것입니다.\n[AWS AppSync](https://aws.amazon.com/appsync/)를 사용하여 API를 구현하고, 데이터 기반 어플리케이션을 구현하기 위하여 관리형 GraphQL 서비스를 사용합니다. 아직 GraphQL이 익숙하지 않다면 워크샵 단계를 진행하기 전에 시간을 내어 다음 자료를 살펴 보세요. [https://graphql.github.io/learn/](https://graphql.github.io/learn/) 단계를 계속하는 동안에도 질문이 생긴다면 위 자료를 참조하시기 바랍니다.  AWS AppSync API 추가하기 photo-albums 디렉토리에서 다음 명령어를 수행하세요 amplify add api\n수행결과는 다음과 같습니다.\n$ amplify add api ? Please select from one of the below mentioned services GraphQL ? Provide API name: photoalbums ? Choose an authorization type for the API Amazon Cognito User Pool ? Do you have an annotated GraphQL schema? No ? Do you want a guided schema creation? Yes ? What best describes your project: One-to-many relationship (e.g., “Blogs” with “Posts” and “Comments”) ? Do you want to edit the schema now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/api/photoalbums/schema.graphql ? Press enter to continue  GraphQL Schema 정의 앨범과 사진을 저장하고 조회하기 위한 스키마 정의입니다.\n 다음 경로의 파일에 photo-albums/amplify/backend/api/photoalbums/schema.graphql 아래 내용을 복사하여 붙여넣습니다. 예제 스키마 컨텐츠를 대체합니다. 파일을 저장하는 것을 잊지 마세요.\n참고 : Cloud9에서 터미널의 파일 이름에 마우스를 올려 놓고 클릭 한 다음 \u0026lsquo;열기\u0026rsquo;를 선택할 수 있습니다.\n# amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! } type PhotoS3Info { key: String! width: Int! height: Int! } 명령 프롬프트로 돌아가서 Enter 를 한번만 눌러 계속 진행합니다.\n amplify push 명령어를 수행하세요 그리고 업데이트를 계속 진행할 것인지 확인합니다.\n 코드 생성에 대한 메세지가 표시되면, \u0026lsquo;No\u0026rsquo;를 선택합니다.\n Amplify가 새로운 리소스를 프로비저닝하는 동안 몇 분 정도 기다립니다.\n  이제 Code 작성 없이 앨범과 사진 데이터에 대하여 CRUDL 작업을 수행할 수 있는 GraphQL API가 생겼습니다!  AWS AppSync가 필드를 데이터로 변환하는 방식이 숨겨져 있는것은 아니니 걱정하지 마세요. 자동으로 생성된 각 resolver들은 우리가 보기에 적절하도록 수정 할 수 있습니다. (다음 단계에서 확인 할수 있습니다) 지금은 앨범을 몇개 추가하고, 그것들을 리스트로 조회해 보겠습니다.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/10_workspace.html",
	"title": "Cloud9 Workspace 생성하기",
	"tags": [],
	"description": "",
	"content": " AWS Cloud9은 cloud-based의 통합 개발 환경(IDE)입니다. 브라우저에서 바로 코드를 작성하고 실행시키고, 디버깅할수 있습니다. Cloud9은 코드 편집기, 디버거와 터미널을 제공합니다. 또한 Javascript, Python, PHP 등의 인기 있는 프로그래밍언어를 위한 필수적인 도구들이 미리 패키징 되어 제공됩니다. 무엇보다도 새로운 프로젝트 시작을 위해 설치 파일이 필요하거나, 개발 환경 설정이 필요하지 않습니다.\nThe Cloud9의 작업영역은 AWS root 계정이 아닌, Administrator 권한을 가진 IAM user에 의해서 작성 되어야 합니다. root 계정이 아닌 IAM User로 로그인 하여 작업 중인게 맞는지 꼭 확인하세요.  광고 차단기, Javascript 비활성화 도구 및 차단 추적기 등은 Cloud9 에서는 비활성화 하세요. 작업 영역에 영향을 줄 수 있습니다.  새 환경 만들기  Cloud9 web console 로 이동 Create environment 선택 workshop으로 이름을 붙이고 Next step으로 넘어가세요. Create a new instance for environment (EC2) 선택하고 t2.medium을 고르세요 모든 환경 설정을 있는 그대로 두고 Next step로 이동합니다. Create environment를 클릭합니다.  Layout 정리 작업 환경이 나타나면, welcome tab을 닫고 레이아웃을 본인에게 맞게 커스터마이징 하세요. 작업 영역을 낮추고, 새로운 terminal 탭을 메인 작업 영역에 띄웁니다. : 당신의 작업 영역은 이제 이렇게 보일거에요.: Cloud9 workspace 메뉴에서 View / Themes / Solarized / Solarized Dark 테마를 직접 선택할 수 있습니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/10_creating_a_photo_processor_lambda.html",
	"title": "Creating a Photo Processor Lambda function",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s make a photo processor lambda function so that we can resize our photos.\nWhen following the instructions below, **you must name your lambda function _workshopphotoprocessor_**.   Later, we'll edit some CloudFormation templates, and the function name **workshopphotoprocessor** is hard coded to make it easier for this workshop (less edits that you'll have to do).   From the photo-albums directory, run: amplify function add and respond to the prompts the same way as shown below. Make sure you press Enter before continuing to step 2:\n$ amplify function add Using service: Lambda, provided by: awscloudformation ? Provide a friendly name for your resource to be used as a label for this category in the project: workshopphotoprocessor ? Provide the AWS Lambda function name: workshopphotoprocessor ? Choose the function template that you want to use: Hello world function ? Do you want to edit the local lambda function now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js ? Press enter to continue \u0026lt;Enter\u0026gt; Successfully added resource workshopphotoprocessor locally. Replace /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js with the following: // amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; function storePhotoInfo(item) { const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const id = uuidv4(); const item = { id: id, owner: metadata.owner, photoAlbumId: metadata.albumid, bucket: bucketName, thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  \n Replace /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/package.json with the following:\n{ \u0026#34;name\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The photo uploads processor\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;sharp\u0026#34;: \u0026#34;^0.20.2\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^3.3.2\u0026#34; } } From the photo-albums directory, run: amplify function build and press Enter to confirm. This will take care of installing the dependencies in our Lambda function\u0026rsquo;s package.json.\n Create photo-albums/amplify/backend/function/workshopphotoprocessor/parameters.json and paste this content into it:\n{ \u0026#34;S3UserfilesBucketName\u0026#34;: \u0026#34;REPLACE_WITH_USERFILES_BUCKET_NAME\u0026#34;, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: \u0026#34;REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN\u0026#34; } In parameters.json that you just created, replace REPLACE_WITH_USERFILES_BUCKET_NAME with the name of the S3 Userfiles bucket created by Amplify.\nTo find this value, look in photo-albums/src/aws-exports.js and find the aws_user_files_s3_bucket key.\n In parameters.json, also replace REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN with the name ARN of the DynamoDB table used by AppSync for the Photo data type.\nTo find this value, go to the Data Sources section in your AppSync API console, find the PhotoTable entry and click on the link in its Resource column (which takes you to the associated DynamoDB table), then look in the bottom of the Overview tab for the ARN of the table.\n Replace photo-albums/amplify/backend/function/workshopphotoprocessor/workshopphotoprocessor-cloudformation-template.json with the following: { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Lambda resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; } }, \t\u0026#34;Resources\u0026#34;: { \u0026#34;LambdaFunction\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::Lambda::Function\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;Handler\u0026#34;: \u0026#34;index.handler\u0026#34;, \u0026#34;FunctionName\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;Role\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34;, \u0026#34;Arn\u0026#34; ] }, \u0026#34;Runtime\u0026#34;: \u0026#34;nodejs8.10\u0026#34;, \u0026#34;Timeout\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;Environment\u0026#34;: { \u0026#34;Variables\u0026#34;: { \u0026#34;ENV\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34;}, \u0026#34;THUMBNAIL_WIDTH\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;THUMBNAIL_HEIGHT\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;DYNAMODB_PHOTOS_TABLE_ARN\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } } \t} }, \u0026#34;LambdaExecutionRole\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Role\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;RoleName\u0026#34;: \u0026#34;photoalbumsLambdaRole91d2faf3\u0026#34;, \u0026#34;AssumeRolePolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;lambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: [ \u0026#34;sts:AssumeRole\u0026#34; ] } ] } } }, \u0026#34;lambdaexecutionpolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;lambda-execution-policy\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*\u0026#34;, { \u0026#34;region\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, \u0026#34;account\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;lambda\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForPhotoAlbums\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForPhotoAlbums\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:s3:::${S3UserfilesBucketName}/*\u0026#34;, { \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3UserfilesBucketName\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForDynamo\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForDynamo\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } ] } } }, \u0026#34;RekognitionDetectLabels\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;RekognitionDetectLabels\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;rekognition:detectLabels\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] \t} } }\t}, \u0026#34;Outputs\u0026#34;: { \u0026#34;Name\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } }, \u0026#34;Arn\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaFunction\u0026#34;, \u0026#34;Arn\u0026#34; ] } }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n From the photo-albums directory, run: amplify push to deploy our new function.\n Wait for the deploy to finish. This step usually only takes about a minute or two.\n  What we changed  Created a parameters.json file to pass some values into the Photo Processor function\u0026rsquo;s CloudFormation template\n Added parameters env, S3UserfilesBucketName, and DynamoDBPhotosTableArn to the Photo Processor function\u0026rsquo;s CloudFormation template\n Added environment variables to the Photo Processor function\u0026rsquo;s configuration: ENV, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, DYNAMODB_PHOTOS_TABLE_ARN\n Added an AllPrivsForPhotoAlbums IAM policy to grant the function\u0026rsquo;s role read and write access to the S3 bucket containing our photos\n Added an AllPrivsForDynamo IAM policy to grant the function\u0026rsquo;s role read and write access to the DynamoDB table containing information about our photos\n Added a RekognitionDetectLabels IAM policy to grant the function\u0026rsquo;s role permission to use the detectLabels API from Amazon Rekognition. This policy isn\u0026rsquo;t used yet, but we\u0026rsquo;re going to add it here for convenience while we\u0026rsquo;re working with this file so we won\u0026rsquo;t need to come back and add it when we get to the next section that involves automatically tagging our photos with AI.\n  The AWS Amplify CLI manages the cloud resources in our project by generating CloudFormation templates for us. CloudFormation templates are very helpful, because they specify all of our project's infrastrucutre as code in the form of JSON and/or YAML files. In this workshop, we'll continue to make edits to some of these generated CloudFormation templates like we did in the steps above.   Beware that not all changes are safe to make, and the Amplify CLI may overwrite edits you make in some CloudFormation templates. All of the changes we make in this workshop will persist and won't get overwritten by Amplify because we're not issuing any commands to re-configure or remove any of the resources we're editing, but it's good to remember that this sort of thing _can_ happen if you attempt to use the CLI to re-configure a resource you've already generated with Amplify.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/10_rekognition.html",
	"title": "Integrating Amazon Rekognition",
	"tags": [],
	"description": "",
	"content": " It would be great if we could find images without having to manually tag them with descriptions of their contents. Luckily, adding this feature is pretty easy thanks to Amazon Rekognition. We can use the DetectLabels API \u0026ndash; if we give it a photo, it will respond with a list of appropriate labels for the image. Perfect!\n**Amazon Rekognition's DetectLabels Quick Summary**  You pass the input image as base64-encoded image bytes or as a reference to an image in an Amazon S3 bucket. If you use the AWS CLI to call Amazon Rekognition operations, passing image bytes is not supported. The image must be either a PNG or JPEG formatted file.  For each object, scene, and concept the API returns one or more labels. Each label provides the object name, and the level of confidence that the image contains the object. For example, suppose the input image has a lighthouse, the sea, and a rock. The response includes all three labels, one for each object.  {Name: lighthouse, Confidence: 98.4629}  {Name: rock,Confidence: 79.2097}  {Name: sea,Confidence: 75.061}  Integrating Rekognition with the Photo Processor Lambda Let\u0026rsquo;s add Amazon Rekognition integration in to our photo_processor lambda function.\nReplace amplify/backend/function/workshopphotoprocessor/src/index.js with the following version:\n// photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const Rekognition = new AWS.Rekognition(); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; async function getLabelNames(bucketName, key) { let params = { Image: { S3Object: { Bucket: bucketName, Name: key } }, MaxLabels: 50, MinConfidence: 70 }; const detectionResult = await Rekognition.detectLabels(params).promise(); const labelNames = detectionResult.Labels.map((l) =\u0026gt; l.Name.toLowerCase()); return labelNames; } function storePhotoInfo(item) {  const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const labelNames = await getLabelNames(bucketName, sizes.fullsize.key); const id = uuidv4(); const item = {  id: id, owner: metadata.owner, labels: labelNames, photoAlbumId: metadata.albumid, bucket: bucketName,  thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  What we changed  Created an instance of AWS.Rekognition to interact with the Amazon Rekognition API\n Added the getLabelNames function to use Rekognition.detectLabels to return a list of appropriate labels for a given photo on S3\n Updated the processPrcord function to use the getLabelNames function to get labels for the photo and include them in the item record it persists to DynamoDB\n  Our Photo Processor code now uses Amazon Rekognition\u0026rsquo;s detectLabels API. But because we already added permissions for this action in the previous section, we won\u0026rsquo;t need to update the CloudFormation template again.\nRe-deploying the Photo Processor Lambda From the photo-albums directory, run: amplify push to deploy an updated version of the Photo Processor function.\nAfter the deploy finishes, try adding a new photo to an album. Then, go look at its row in the PhotoTable in DynamoDB and see if you see a labels property for the new upload. Hopefully you see some relevant labels for the photo!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/10_lightbox_photos.html",
	"title": "Making a Lightbox for Viewing Fullsize Photos",
	"tags": [],
	"description": "",
	"content": " One thing we haven\u0026rsquo;t yet addressed in our app is adding the ability for users to click on a photo thumbnail to see a larger version of the photo. Since we already have the fullsize and the thumbnail data available to query from our API, all we need to do is update our front end application with a few more lines of code.\nUpdating the front end Replace photo-albums/src/App.js with the following updated version: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); }  photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)}  /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt;  \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported the Container and Modal components from semantic-ui-react\n Added additional fields to our GetAlbum GraphQL query to fetch fullsize photo info\n Updated the PhotosList component to track the currently selected photo and pass it to a nested Lightbox component\n Created a Lightbox component to render a selected photo\u0026rsquo;s fullsize content in a modal display\n  Try out the app Check out the app again and try clicking on any photo thumbnails. You should now see a fullsize version pop up. Clicking the photo will dismiss it and return to the thumbnails view.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/10_what_we_will_build.html",
	"title": "무엇을 빌드하나",
	"tags": [],
	"description": "",
	"content": " 목표 이 워크샵에서 다음을 포함한 몇 가지 기능이 있는 앱을 빌드합니다.\n 사용자 등록과 인증을 지원해서 사진 앨법을 누가 소유했는지 알 수 있습니다.\n API 서버를 빌드하여 프론트엔드는 사용자에게 맞는 앨범과 사진을 적재할 수 있습니다.\n 누가 무엇을 볼 수 있는가에 권한 정보, 앨범, 사진을 저장하여 API는 조회와 저장을 위한 빠르고 신뢰성있는 저장소를 갖습니다.\n 사진을 저장하고 제공하며 사용자가 앨범에 업로드하는 모든 사진을 저장할 수 있습니다.\n 자동으로 사진 썸네일을 작성하여 사용자가 포토 앨범 목록을 살펴볼 때에 전체 해상도의 사진을 제공하지 않습니다.\n 자동으로 업로드한 사진과 연관된 레이블을 감지하고 이에 기반하여 검색 할 수 있게 합니다.\n  구성도 다음은 앞으로 사용할 서비스와 각각이 어떻게 연결되었는지 표시한 구성도입니다.\n사용 도구 위에 언급한 각각의 문제를 처리할 수 있는 확장 가능하고 고가용성의 시스템을 만들고자 한다면, 아마 결코 앱을 만들 수 없을 것입니다! 다행히 AWS는 현대적이고 견고한 애플리케이션 구축에 필요하지만 무겁고 많은 묶인 짐을 다룰 수 있는 서비스와 도구를 제공합니다. 우리는 다음의 다양한 도구와 서비스를 사용할 것입니다.\n AWS Amplify CLI는 클라우드 서비스를 빠르게 프로비저닝하고 구성합니다.\n AWS Amplify JavaScript 라이브러리는 프론트와 클라우드 리소스를 연결합니다.\n Amazon Cognito는 사용자 등록과 인가를 처리합니다.\n Amazon Simple Storage Service (S3)는 사용자가 업로드한 많은 사진을 저장하고 제공하며 앱의 정적 에셋을 호스팅합니다.\n Amazon DynamoDB는 사진과 앨범 데이터에 대한 API 쿼리를 수밀리초 응답으로 제공합니다.\n AWS AppSync는 프론트엔드에 GraphQL API를 호스팅합니다.\n AWS Lambda는 클라우드에서 사진의 썸네일을 비동기적으로 생성합니다.\n Amazon Rekognition는 업로드한 사진의 연관된 레이블을 감지합니다.\n Amazon Elasticsearch Service는 사진의 레이블을 검색하고 색인을 생성합니다.\n  이 서비스의 일부 혹은 전부가 다 새로울 지라도 걱정하지 마십시오. 위에 언급한 모든 것을 사용해서 시작할 때에 알아야 할 모든 것을 다룰 것입니다. 무엇보다 빌드보다 더 좋은 배움의 방법은 없으니 시작합시다!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/10_adding_auth_back.html",
	"title": "백엔드 구성하기",
	"tags": [],
	"description": "",
	"content": " 이제 우리에게 간단한 리액트 앱이 있으니, 앱으로 사용자 등록하고 로그인하도록 만들겠습니다. 지금 아무 것도 할 수 없지만 백엔드 API에 조회하는 기능을 추가하면 어떤 사용자가 우리 시스템을 사용하는지 알 수 있습니다.\nAWS Amplify CLI는 리엑트와 리엑트 네이티브용 iOS와 안드로이드에 SDK를 제공하여 웹과 모바일 앱에 클라우드 기능을 손쉽게 추가할 수 있습니다. 시작을 위해 새 애플리케이션을 만들고 사용자 인증을 가능토록 합니다. 앱에 AWS Amplify CLI로 구성하여 앱과 오픈소스 [AWS Amplify](https://aws-amplify.github.io/) 라이브러리를 연결합니다. 이제 해야 할 것은 리액트 앱에서 이것을 사용하면 됩니다. AWS Amplify는 클라우드 서비스에서 동작하는 괜찮은 추상화와 앱에서 사용할 유용한 리액트 컴포넌트를 포함합니다.  로그인 화면은 다음과 같습니다. Amplify 초기화 ** 커맨드라인으로 photo-albums 디렉터리에서**:\n photo-albums 디렉터리로 들어갑니다. cd photo-albums\n amplify init를 실행합니다.\n \u0026lsquo;photo-albums\u0026rsquo;을 기본 프로젝트명으로 하기 위해 _Enter_를 누르십시요.\n environment name은 \u0026lsquo;dev\u0026rsquo;를 입력합니다.\n default editor(우리는 Cloud9을 씁니다)로 \u0026lsquo;None\u0026rsquo; 선택하십시요.\n 프롬프트가 나오면 JavaScript와 React를 선택하십시요.\n 경로와 명령어에는 기본값을 선택합니다.\n 프롬프트가 나오면 default 프로파일을 선택하십시요.\n  이렇게 하면 [Amazon Cognito](https://aws.amazon.com/cognito/) 유저 풀을 구성하여 사용자가 가입하고 로그인을 위한 백엔드 역할을 할 수 있는 새 로컬 구성을 생성합니다(Amazon Cognito와 유저 풀에 대한 자세한 내용은 아래에 있습니다). 이 단계를 더 자세히 아시려면 [AWS Amplify 인증 가이드](https://aws-amplify.github.io/amplify-js/media/authentication_guide.html)에서 'Installation and Configuration' 항목을 살펴보십시요.  인증 추가하기  인증을 추가하기 위해 amplify add auth를 실행합니다.\n 기본 인증 및 보안 구성을 사용할지 질문에는 Yes를 선택합니다.\n 클라우드에 변경 사항을 반영하기 위해 amplify push를 실행합니다.\n 프로비저닝이 완료될 때까지 기다립니다. 몇 분이 소요됩니다.\n  Amplify CLI는 적절한 클라우드 리소스로 프로비저닝하고 src/aws-exports.js 파일을 앱에서 사용하는 클라우드 리소스의 모든 구성 데이터로 갱신합니다.  축하합니다! 바로 방금 귀하는 Amazon Cognito로 수백만 사용자까지 확장할 수 있는 사용자 등록과 권한 부여를 위한 서버리스 백엔드를 만들었습니다.\nAmazon Cognito를 사용하면 웹과 모바일 애플리케이션에 사용자 등록, 로그인, 접근제어 기능을 쉽고 빠르게 추가할 수 있습니다. 방금 생성한 유저 풀은 보안된 사용자 디렉터리로 이를 이용하여 사용자가 생성한 사용자명과 암호로 로그인할 수 있습니다. Amazon Cognito(Amplify CLI 함께)는 또한 Facebook, Google, Amazon 같은 소셜 인증 공급자와 SAML 2.0을 통한 엔터프라이즈 인증 공급자를 이용한 로그인 구성도 지원합니다. 자세한 내용을 알기 원하시면 [Amazon Cognito Developer Resources page](https://aws.amazon.com/cognito/dev-resources/)와 [AWS Amplify Authentication documentation.](https://aws-amplify.github.io/amplify-js/media/authentication_guide#federated-identities-social-sign-in)를 살펴보십시요.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84.html",
	"title": "사전준비",
	"tags": [],
	"description": "",
	"content": " Workshop 사전 준비  AWS account 생성하기   Cloud9 Workspace 생성하기   설치 \u0026amp; 설정   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/10_what_we_built.html",
	"title": "축하드립니다!",
	"tags": [],
	"description": "",
	"content": " 실제로 상용할 어플리케이션을 만들진 않았지만, 간단하게 공유가능한 앨범 웹 앱을 만들어보았습니다.\n우리가 완료한 내용들을 다음 리스트에서 확인해보겠습니다. 우리는 :\n 간단한 리엑트(React) 웹 앱으로 시작했습니다.\n 사용자인증 추가로 완벽한 회원가입 및 로그인을 구현하였습니다.\n DynamoDB 테이블에 적재될 사진 앨범들이 안전하게 관리되도록 AWS AppSync의 GraphQL API를 이용했습니다.\n 앨범추가 및 보기기능을 추가하였습니다.\n 앨범에 사진들을 업로드하고 썸네일 자동생성을 완료하였습니다.\n 사진이 많은 앨범의 \u0026ldquo;더보기\u0026rdquo;와 같이 페이지매김을 도입하였습니다.\n Amazon Rekognition API를 이용한 사진의 자동라벨 감지기능 추가하였습니다.\n (각 사용자별로 지정된 앨범권한 범위 내에서) 라벨이 주어진 전체사진을 검색할 수 있는 기능을 추가하였습니다.\n 프로덕션 버전 앱을 만들고 웹 호스팅을 할 수 있게 S3버킷으로 배포했습니다.\n 우리가 제작한 앱은 완전한 서버리스이며, AWS서비스 덕분에 비용효율적이며 뛰어난 확장성과 고가용성이라는 장점이 있습니다.\n  몇시간동안 우리가 한 작업이 괜찮은 것 같네요!\n마지막까지 완수해주신 여러분 스스로를 자랑스러워 해주세요!\n다음엔 무엇을 구축해보시겠어요? "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/20_album_membership.html",
	"title": "Allowing Other Users To Collaborate In Albums",
	"tags": [],
	"description": "",
	"content": " We can take advantage of the fact that multiple users can sign in to our app and add the ability for other people view and upload to our albums on a case-by-case basis.\nThe simplest way to do this is to have each album contain a set of usernames that are allowed to view and upload photos to it. Let\u0026rsquo;s see how we can make this work.\nUpdating the backend Amplify supports multiple authorization declarations on the @model types in our GraphQL Schema. We can add a second auth rule, stating that any user who\u0026rsquo;s username is in an Album\u0026rsquo;s members field can see (but not edit) the record.\n Replace /photo-albums/amplify/backend/api/photoalbums/schema.graphql with the following: # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [ { allow: owner } { allow: owner, ownerField: \u0026#34;members\u0026#34;, queries: [get, list], mutations: null } ]) {  id: ID! name: String! owner: String members: [String] photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! } \n Run amplify push to regenerate a new GraphQL schema and update our AppSync API.\n  You can learn more about adding multiple ownership rules to a model in [the GraphQL Transform documentation](https://aws-amplify.github.io/docs/cli/graphql?sdk=js).  Updating the frontend Now that our backend has been updated to look for a list of usernames in a members field on our album records, all we need to do is update our UI to allow an album\u0026rsquo;s owner to manage the usernames that should be considered members of the album. We\u0026rsquo;ll also add in another AppSync subscription so that our listing of usernames will refresh when a new username is added to an album.\nReplace photo-albums/src/App.js with the following updated version: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Icon, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, Auth, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const SubscribeToUpdatedAlbums = ` subscription OnUpdateAlbum { onUpdateAlbum { id name owner members } } `;  const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name owner members photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); } photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); const subscription = API.graphql(graphqlOperation(SubscribeToUpdatedAlbums)).subscribe({ next: (update) =\u0026gt; { const album = update.value.data.onUpdateAlbum; this.setState({ album: Object.assign(this.state.album, album) }) } }); this.setState({ albumUpdatesSubscription: subscription }) } componentWillUnmount() { this.state.albumUpdatesSubscription.unsubscribe(); }  render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } } class AlbumDetails extends Component { async componentDidMount() { this.setState({ currentUser: await Auth.currentAuthenticatedUser() }); }  render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; { this.state.currentUser.username === this.props.album.owner \u0026amp;\u0026amp; \u0026lt;Segment.Group\u0026gt; \u0026lt;Segment\u0026gt; \u0026lt;AlbumMembers members={this.props.album.members} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;Segment basic\u0026gt; \u0026lt;AddUsernameToAlbum albumId={this.props.album.id} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;/Segment.Group\u0026gt; }  \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AddUsernameToAlbum extends Component { constructor(props) { super(props); this.state = { username: \u0026#39;\u0026#39; }; } handleChange = (e, { name, value }) =\u0026gt; this.setState({ [name]: value }) handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.albumId})); let updatedAlbum = data.getAlbum; const updatedMembers = (data.getAlbum.members || []).concat([this.state.username]); updatedAlbum.members = updatedMembers; const {id, name, owner, members} = updatedAlbum; const updatedAlbumInput = {id, name, owner, members}; const UpdateAlbum = `mutation UpdateAlbum($input: UpdateAlbumInput!) { updateAlbum(input: $input) { id members } } `; const result = await API.graphql(graphqlOperation(UpdateAlbum, { input: updatedAlbumInput })); console.log(`Added ${this.state.username}to album id ${result.data.updateAlbum.id}`); this.setState({ username: \u0026#39;\u0026#39; }); } render() { return ( \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Username\u0026#39; icon=\u0026#39;user plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Add\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;username\u0026#39; value={this.state.username} onChange={this.handleChange} /\u0026gt; ) } } const AlbumMembers = (props) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h4\u0026#39;\u0026gt; \u0026lt;Icon name=\u0026#39;user circle\u0026#39; /\u0026gt; \u0026lt;Header.Content\u0026gt;Members\u0026lt;/Header.Content\u0026gt; \u0026lt;/Header\u0026gt; { props.members ? \u0026lt;List bulleted\u0026gt; {props.members \u0026amp;\u0026amp; props.members.map((member) =\u0026gt; \u0026lt;List.Item key={member}\u0026gt;{member}\u0026lt;/List.Item\u0026gt;)} \u0026lt;/List\u0026gt; : \u0026#39;No members yet (besides you). Invite someone below!\u0026#39; } \u0026lt;/div\u0026gt; );  class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported Icon from semantic-ui-react and Auth from aws-amplify\n Added SubscribeToUpdatedAlbums query\n Added owner and member fields to be fetched by the GetAlbum query\n Subscribed to album updates inside the AlbumDetailsLoader component in order to trigger a re-rendering of the album when new members are added\n Updated the AlbumDetails component\u0026rsquo;s render() method to include UI for managing members\n Created AddUsernameToAlbum and AlbumMembers components to handle adding and listing album members and only render these components if the user owns the album\n  Try out the app To test out our new multi-user capabilities, we\u0026rsquo;ll need at least one other user to invite to an album.\n Sign out of the app and create a new user (don\u0026rsquo;t forget to check for the verification email and submit the verification code).\n Sign out of the new username and back in using your original username.\n Navigate to an album you\u0026rsquo;d like to share and invite your new username to the album.\n Sign out and then back in with the new username and you\u0026rsquo;ll see the album listed! You should also notice that the album membership controls aren\u0026rsquo;t visible since this user doesn\u0026rsquo;t own the album.\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/20_connecting_the_lambda_to_the_bucket.html",
	"title": "Connecting the photos bucket to the processor function",
	"tags": [],
	"description": "",
	"content": " Triggering the function when new photos are uploaded to the S3 bucket Now that we\u0026rsquo;ve created our Photo Processor function, we need to set up a trigger for it to run. Since we want to process every photo that gets uploaded to an album, we\u0026rsquo;ll make these changes by updating the configuration of the S3 userfiles bucket that Amplify created for us.\n Replace photo-albums/amplify/backend/storage/photoalbumsstorage/s3-cloudformation-template.json with the following: { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;S3 resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;bucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }  }, \u0026#34;Conditions\u0026#34;: { \u0026#34;ShouldNotCreateEnvResources\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; }, \u0026#34;NONE\u0026#34; ] }, \u0026#34;EnableUnauthReadWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;rw\u0026#34; ] }, \u0026#34;EnableUnauthRead\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;r\u0026#34; ] }, \u0026#34;EnableUnauthWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthPermissions\u0026#34; }, \u0026#34;w\u0026#34; ] }, \u0026#34;EnableAuthReadWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;rw\u0026#34; ] }, \u0026#34;EnableAuthRead\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;r\u0026#34; ] }, \u0026#34;EnableAuthWrite\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authPermissions\u0026#34; }, \u0026#34;w\u0026#34; ] } }, \u0026#34;Resources\u0026#34;: { \u0026#34;InvokePhotoProcessorLambda\u0026#34;: { \u0026#34;Type\u0026#34; : \u0026#34;AWS::Lambda::Permission\u0026#34;, \u0026#34;Properties\u0026#34; : { \u0026#34;Action\u0026#34; : \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;FunctionName\u0026#34; : \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;Principal\u0026#34; : \u0026#34;s3.amazonaws.com\u0026#34;, \u0026#34;SourceAccount\u0026#34; : { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;SourceArn\u0026#34;: \u0026#34;arn:aws:s3:::REPLACE_WITH_USERFILES_BUCKET_NAME\u0026#34; } }, \t\u0026#34;S3Bucket\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::S3::Bucket\u0026#34;, \u0026#34;DeletionPolicy\u0026#34; : \u0026#34;Retain\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Fn::If\u0026#34;: [ \u0026#34;ShouldNotCreateEnvResources\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, \u0026#34;-\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; } ] ] } ] }, \u0026#34;CorsConfiguration\u0026#34;: { \u0026#34;CorsRules\u0026#34;: [ { \u0026#34;AllowedHeaders\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;AllowedMethods\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;HEAD\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34; ], \u0026#34;AllowedOrigins\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;ExposedHeaders\u0026#34;: [ \u0026#34;x-amz-server-side-encryption\u0026#34;, \u0026#34;x-amz-request-id\u0026#34;, \u0026#34;x-amz-id-2\u0026#34; ], \u0026#34;Id\u0026#34;: \u0026#34;S3CORSRuleId1\u0026#34;, \u0026#34;MaxAge\u0026#34;: \u0026#34;3000\u0026#34; } ] }, \u0026#34;NotificationConfiguration\u0026#34;: { \u0026#34;LambdaConfigurations\u0026#34;: [ { \u0026#34;Function\u0026#34;: { \u0026#34;Fn::Join\u0026#34;: [\u0026#34;:\u0026#34;, [ \u0026#34;arn:aws:lambda\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;function\u0026#34;, \u0026#34;workshopphotoprocessor\u0026#34; ] ] }, \u0026#34;Event\u0026#34;: \u0026#34;s3:ObjectCreated:Put\u0026#34;, \u0026#34;Filter\u0026#34;: { \u0026#34;S3Key\u0026#34;: { \u0026#34;Rules\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;prefix\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;uploads/\u0026#34; } ] } } } ] } \t} }, \u0026#34;DenyListS3Buckets\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;DenyListS3Buckets\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [\u0026#34;*\u0026#34;] } ] } } }, \t\u0026#34;S3UnauthPolicyRW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthReadWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } } ] } } }, \u0026#34;S3UnauthPolicyR\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthRead\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3UnauthPolicyW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableUnauthWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthPolicyRW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthReadWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] } } } ] } } }, \u0026#34;S3AuthPolicyR\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthRead\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthPolicyW\u0026#34;: { \u0026#34;Condition\u0026#34;: \u0026#34;EnableAuthWrite\u0026#34;, \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;authPolicyName\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34;, \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:DeleteObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] } } } ] } } } }, \u0026#34;Outputs\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;Description\u0026#34;: \u0026#34;Bucket name for the S3 bucket\u0026#34; }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n After you paste the new template shown above, find the text **REPLACE_WITH_USERFILES_BUCKET_NAME** in your pasted template and replace it with the name of your userfiles S3 bucket.   You can find this value in **photo-albums/src/aws-exports.js** under the **aws_user_files_s3_bucket** key.  From the photo-albums directory, run: amplify push to update our storage configuration.\n Wait for the update to complete. This step usually only takes a minute or two.\n  What we changed in amplify/\u0026hellip;/s3-cloudformation-template.json  Added a env parameter, allowing Amplify to pass in the current Amplify environment name to the template\n Added a InvokePhotoProcessorLambda resource, giving the S3Bucket permission to invoke the PhotoProcessor lambda function.\n Added a NotificationConfiguration property to the S3Bucket resource, configuring the bucket to invoke our PhotoProcessor lambda function when new photos are added to the \u0026lsquo;uploads/\u0026rsquo; prefix\n Added a DenyListS3Buckets IAM policy, preventing authenticated users from listing the contents of any buckets on S3\n  The default permissions for the user files S3 storage bucket set up by the Amplify CLI allows anyone logged in to our app to list the contents of the bucket for any keys that start with 'public/' (and a few other prefixes too). While our app doesn't expose this as an interaction, someone poking around might try to take their credentials from our app and make an API call to S3 directly to try and list the bucket where all the photos are going.   We have no need to let users list bucket contents at all, so we've added an IAM policy to the role used by authenticated users to explicitly deny users the ability to list any S3 bucket contents.   Now, nobody will be able to go directly to the S3 API and list all of the photos that our users have uploaded. We're using UUIDs for album and photo IDs, so we shouldn't have to worry about a curious user enumerating through patterns of IDs hoping to find photos to view.  Try uploading another photo With these changes completed, we should be able to upload a photo and see our Photo Processor function execute automatically. Try uploading a photo to an album, wait a moment, then refresh the page to see if the album renders the newly uploaded photo. If you see a photo, it means that our Photo Processor function was automatically triggered by the upload, it created a thumbnail, and it added all of the photo information to the DynamoDB table that our AppSync API reads from for resolving Photos.\nRefreshing the album view in order to see new photos isn’t a great user experience, but this workshop has a lot of material already and there’s still more to cover in the next section, too. In short, one way to handle this with another AppSync subscription would be to have our photo processor Lambda function trigger a mutation on our AppSync API, and to have the AlbumDetailsLoader component subscribe to that mutation. However, because we’re using Amazon Cognito User Pool authentication for our AppSync API, the only way to have our Lambda function trigger such a mutation would be to create a sort of ‘system’ user (through the normal user sign up and confirmation process), store that user’s credentials securely (perhaps in AWS Secrets Manager), and authenticate to our AppSync API as that user inside our Lambda in order to trigger the mutation. For simplicity\u0026rsquo;s sake, we\u0026rsquo;ll stick to just refreshing the album view for this workshop.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/20_prep_for_searching.html",
	"title": "Making Photos Searchable",
	"tags": [],
	"description": "",
	"content": " Updating the GraphQL Schema Now that we are storing labels for each photo, we\u0026rsquo;re ready to move on and expose this data via our AppSync API.\nWhile it\u0026rsquo;s possible to perform some level of searching via DynamoDB Query operations, a more flexible and performant approach is to use the Amazon Elasticsearch Service to index data and handle our search queries. Fortunately, the Amplify CLI makes creating an Amazon Elasticsearch Service endpoint, and connecting it to our app\u0026rsquo;s data, very easy.\n Replace /photo-albums/amplify/backend/api/photoalbums/schema.graphql with the following: # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable {  id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! }\n From the photo-albums directory, run: amplify push to provision our new resources.\n Wait for the update to finish. Creating a new Amazon Elasticsearch Service endpoint can take several minutes. This step usually takes 8 to 12 minutes to complete.\n  You can learn more about Amplify's *@searchable* GraphQL directive in [Amplify's GraphQL Transform documentation](https://aws-amplify.github.io/docs/cli/graphql?sdk=js).  What we changed  Added the @searchable directive to the Photo type, which will have Amplify connect Photo data to an Amazon Elasticsearch Service cluster\n Added a new labels propery to the Photo type so that the labels information added by the Photo Processor function will also be streamed as part of each Photo record into the Elasticsearch Service for us to search on\n  You can continue on to the next section while you're waiting for the `amplify push` to complete.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/20_trying_out_queries.html",
	"title": "Querie 수행하기",
	"tags": [],
	"description": "",
	"content": " AWS Console로 접근하여 photoalbums API를 클릭합니다. 이제 API를 파고들어봅시다.\n Link to AWS AppSync web console in Northern Virgina\n Link to AWS AppSync web console in Ireland\n \n왼쪽 사이드바에 있는 Queries를 클릭합니다.\nAWS AppSync의 대화형 쿼리 실행 영역인 이곳에서 쿼리를 작성하거나 변경하고, 쿼리를 실행하여 결과를 볼 수 있습니다. 이는 Resolver들이 우리가 예상한 대로 잘 작동하는지 테스트하기 위한 좋은 방법입니다.  AppSync 인증 쿼리를 실행하기 전에 사용자 인증이 필요합니다. (AppSync API는 Application 인증을 구현할때 세팅한 Amazon Congnito 사용자 Pool을 통하여 인증하도록 설정되어 있기 때문)   쿼리 에디터 상단에 있는 Login with User Pools 버튼을 클릭하세요.\n ClientId 필드의 값을 확인합니다.\n Cloud9에서 photo-albums/src/aws-exports.js 파일을 오픈합니다. aws_user_pools_web_client_id 속성의 값을 복사 하세요.  ClientId 필드에 복사한 값을 붙여넣습니다.\n 인증 정보를 추가할때 생성한 사용자 credentials 을 입력하세요.\n Login 클릭\n  쿼리 수행하기 이제 다음 쿼리와 Mutations를 수행하면 됩니다. 쿼리와 mutations 실행을 위해 주황색 \u0026lsquo;play\u0026rsquo; 버튼을 클릭하세요.\n새로운 앨범 추가하기 : 다음 문장을 복사 붙여넣기 하여 쿼리를 실행합니다.\nmutation { createAlbum(input:{name:\u0026quot;First Album\u0026quot;}) { id name } }  다른 앨범 추가하기 : 다른 앨범 이름으로 createAlbum mutation를 수정하고 재실행 합니다.\nmutation { createAlbum(input:{name:\u0026quot;Second Album\u0026quot;}) { id name } }  앨범 목록 조회하기 : 다음 쿼리를 실행합니다.\nquery { listAlbums { items { id name } } }  보다시피, GraphQL 쿼리와 mutation으로 데이터를 읽고 작성할 수 있습니다. AppSync는 데이터 조회와 데이터 보존(Persisting)을 담당합니다.(이 예시는 DynamoDB에 해당).\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/20_cleanup.html",
	"title": "리소스 삭제하기",
	"tags": [],
	"description": "",
	"content": " Amplify로 삭제하기 Amplify는 우리가 이번 워크샵에서 프로비저닝했던 모든 리소스들을 삭제할 수 있는 작업을 할 수 있습니다 (프로비저닝된 CloudFormation 중첩스택을 삭제하는 작업을 시도합니다). 그러나 몇가지 리소스들은 삭제거부가 되므로, 수동으로 삭제해줍니다.\n photo-albums 디렉토리에서 amplify delete를 실행하고 삭제를 확인하기 위해 *Enter*키를 누릅니다.\n Amplify가 리소스들을 삭제하는 동안 기다립니다.\n  수동으로 일부 삭제하기 이제 CloudFormation stacks console로 이동해서 \u0026lsquo;DELETE FAILED\u0026rsquo;상태표시를 나타내는 몇개의 스택들을 클릭합니다. 귀하께서는 삭제실패된 원인과 무엇이 실패되었는지를 보실 수 있습니다.\nCloudFormation이 스택들을 삭제하려고 할 때 정책들이 연동되어있다면 삭제되지 않으므로 인증된 사용자의 IAM역할이 실패하는 것입니다. 그러나, 이 시점에서 모든 정책들은 모두 삭제되어야하며 다른 스택들을 삭제하려는 작업시도는 성공되어야합니다.\n 삭제실패된 스택을 선택합니다.\n Actions을 클릭합니다.\n 스택삭제를 선택합니다.\n Auth 역할을 클릭해제하고, 예, 삭제합니다를 클릭합니다.\n 성공적으로 삭제되었는지 확인합니다. 만약 삭제되지 않았다면, IAM Roles console으로 이동한 후, 해당역할( \u0026lsquo;photoalbums\u0026rsquo;로 시작합니다 )을 검색해서 선택 및 삭제해주세요.\n  Amplify가 생성한 S3 버킷은 자동적으로 삭제하지 않습니다. 버킷을 삭제하려면 다음 단계를 따르세요 :\n S3 console로 이동합니다.\n 생성일자열을 클릭하여 최근생성된 버킷들을 순차적으로 정렬합니다.\n 각 _photoalbums*_버킷별로 클릭하고 버킷 삭제버튼을 클릭하여 삭제 확인을 하기위해 버킷명을 복사/붙여넣기합니다.\n  Cloud9 워크스페이스 삭제하기  Cloud9 Environment로 이동합니다.\n workshop으로 생성된 개발환경을 선택 후 삭제를 누릅니다.\n 확인란에 \u0026lsquo;삭제\u0026rsquo;구문을 입력하고 삭제를 클릭합니다.\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_%EC%82%AC%EC%A0%84%EC%A4%80%EB%B9%84/20_software.html",
	"title": "설치 &amp; 설정",
	"tags": [],
	"description": "",
	"content": " 코딩을 시작하기 전에, Cloud9 환경에 몇 가지 설치, 업데이트, 설정을 해야합니다.\n설치와 업데이트 Cloud9 터미널에서 다음 명령어를 수행하세요. 우리가 사용할 몇 가지 소프트웨어를 설치하고 업데이트 합니다.\n# Update the AWS CLI pip install --user --upgrade awscli # Install and use Node.js v8.10 (to match AWS Lambda) nvm install v8.10.0 nvm alias default v8.10.0 # Install the AWS Amplify CLI npm install -g @aws-amplify/cli 이 명령어들은 완료 되는데 시간이 좀 걸릴수 있습니다. (few minutes)  기본 region 설정하기 가장 좋은 방법은 인프라를 고객과 가까운 지역에 구성하는 것입니다. (Amplify는 아직 서울 리전을 지원하지 않습니다.)\n이번 워크샵에서는 기본 AWS region을 다음 지역으로 설정합니다:\n- 미국 - Northern Virginia (us-east-1)\n- 유럽 - Ireland (eu-west-1)\nAWS config file 생성하기, 실행:\n cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=us-east-1 END  cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=eu-west-1 END  \nAWS Amplify CLI는 모바일과 웹 어플리케이션을 개발을 심플하게 해주는 강력한 기능들을 제공하는 툴체인 입니다. 위의 단계에서는 설치만 진행했기 때문에 설정 단계가 추가적으로 필요합니다. AWS Amplify CLI는 **~/.aws/config**을 찾아 작업할 Region 정보를 판별합니다. Cloud9은 유효한 Administrator credentials이 **~/.aws/credentials** 파일안에 있는지 확인만 할 뿐 **~/.aws/config**을 생성하지 않습니다.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started.html",
	"title": "시작하기",
	"tags": [],
	"description": "",
	"content": " 시작하기  무엇을 빌드하나   앱 부트스트래핑   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/20_bootstrapping_the_app.html",
	"title": "앱 부트스트래핑",
	"tags": [],
	"description": "",
	"content": " 리액트(React) 앱 만들기 create-react-app CLI로 새로운 리액트 웹 앱을 제작하며 시작하겠습니다.\n이는 로컬에서 자동으로 다시 서버를 띄워주는 리액트 샘플 앱과 브라우저에서 async/await 문법, 화살표 함수 등을 지원하도록 트랜스 컴파일 기능을 제공합니다.  create-react-app은 [https://github.com/facebook/create-react-app](https://github.com/facebook/create-react-app)에서 좀 더 배울 수 있습니다.  Cloud9 터미널에서 npx create-react-app photo-albums를 실행하시고 새로 생성된 디렉토리로 이동합니다 cd photo-albums\n시멘틱 UI 리액트 추가하기 UI를 작성하기 전에 인터페이스를 좀 더 근사하게 만들수 있는 리액트의 시멘틱 UI 컴포넌트를 추가합니다.\nphoto-albums 디렉터리에서 npm install --save semantic-ui-react 실행합니다.\n그리고 public/index.html를 수정하고 이 스타일 시트 링크를 추가합니다.\n\u0026lt;head\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.3.3/semantic.min.css\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/head\u0026gt; 앱 띄워 보기 이제 개발 서버에서 시작해서 수정하면 브라우저에서 즉각 새로고침하여 볼 수 있게 합니다.\nphoto-albums 디렉터리에서 npm start를 실행합니다.\n웹 서버를 시작했으면 Preview 메뉴를 클릭하고 Preview Running Application을 선택합니다.\n원하시면 미리보기를 새 창에 표시할 수 있습니다.\n마지막으로 다른 터미널 윈도우를 엽니다. 첫번째 터미널은 웹 서버 프로세스를 실행 중이므로 남겨둡니다. 마크업 단순화하기 다음으로 깨끗한 상태로 시작하고 싶습니다.\nsrc/App.js를 수정하여 간단히 \u0026lsquo;Hellow World\u0026rsquo; 메시지를 보여주도록 바꿉니다. 파일의 기존 내용을 아래와 같이 변경합니다.\n// src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default App; 이 시점에서 이전에 띄워둔 브라우저는 자동으로 새로고침되고 'Hello World'라는 텍스트만 있는 훨씬 간단한 페이지가 표시할 것입니다. 아직 못 보았지만 최소한의 마크업으로 시작하는 것이 좋습니다.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/20_adding_auth_front.html",
	"title": "프론트엔드 렌더링",
	"tags": [],
	"description": "",
	"content": " 이제 등록과 로그인을 관리하는 백엔드가 구성되었으니 withAuthenticator AWS Amplify의 상위 리액트 컴포넌트를 이용해서 기존 App 컴포넌트를 감싸도록 합니다. 그러면 앱에서 사용자 등록, 확인, 로그인, 로그 아웃, 비밀번호 재설정을 할 수 있는 간단한 UI를 제공합니다.\nAmplify NPM 종속성 추가 아직 aws-amplify, aws-amplify-react 모듈을 앱에 추가하지 않았으니 이제 추가합니다.\n npm install --save aws-amplify aws-amplify-react을 실행합니다.\n src/App.js 내용을 다음으로 교체합니다. // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; import Amplify from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; import { withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; Amplify.configure(aws_exports);  class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true});\n  이제 웹 앱을 살펴보면, 사용자 등록과 로그인 양식을 갖게 되었음을 알 수 있습니다!\nApp.js에서 변경한 것들  AWS Amplify JS 라이브러리를 임포트하고 구성했습니다.\n aws-amplify-react에서 withAuthenticator 상위 컴포넌트를 임포트했습니다.\n withAuthenticator로 App 컴포넌트를 감쌌습니다.\n  계정 생성하기 앱에서 계정을 생성하려면 사용자명, 암호와 유효한 이메일 주소(확인 코드를 수신할)가 필요합니다.\n코드를 확인하라는 화면이 보여집니다. 이는 Amazon Cognito가 로그인할 수 있게 하기 전에 사용자의 이메일 주소를 검증하기 때문입니다.  이메일을 확인하십시요. 확인 코드를 받았을 것입니다. 확인 코드를 복사하고 앱에 붙여넣기 하면 가입시 입력한 사용자명과 비밀번호로 로그인할 수 있습니다.\n로그인하면 로그인 양식은 사라지고 사용자명과 \u0026lsquo;Sing Out\u0026rsquo; 버튼이 포함된 헤더바 아래로 랜더링된 App 컴포넌트를 볼 수 있습니다.\n지금은 꽤 간단한 인증 UI이지만 직접 리액트 컴포넌트를 교체하거나 앱으로 리다이렉션할 수 있는 완전히 호스트된 UI를 사용하는 등의 많은 것을 사용자가 정의할 수 있습니다. 자세한 내용은 [AWS Amplify 인증 가이드](https://aws.github.io/aws-amplify/media/authentication_guide#customization)의 사용자 정의 항목을 보십시요.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/30_adding_storage.html",
	"title": "Adding Cloud Storage",
	"tags": [],
	"description": "",
	"content": " We\u0026rsquo;ll need a place to store all of the photos that get uploaded to our albums. Amazon Simple Storage Service (S3) is a great option for this and Amplify\u0026rsquo;s Storage module makes setting up and working with S3 very easy.\nYou can read more about Amplify's Storage module [here](https://aws-amplify.github.io/amplify-js/media/storage_guide).  Configuring and adding storage First, we\u0026rsquo;ll use the Amplify CLI to enable storage for our app. This will create a bucket on Amazon S3 and set it up with appropriate permissions so that users who are logged in to our app can read from and write to it.\n From the photo-albums directory, run amplify add storage\n Select \u0026lsquo;Content\u0026rsquo; at the prompt\n Enter values or accept defaults for the resource category and bucket name\n Configure it so that only authenticated users have access with read/write permissions.\nHere is sample output with responses:\n$ amplify add storage ? Please select from one of the below mentioned services: Content (Images, audio, video, etc.) ? Please provide a friendly name for your resource that will be used to label this category in the project: photoalbumsstorage ? Please provide bucket name: \u0026lt;accept the default value\u0026gt; ? Who should have access: Auth users only ? What kind of access do you want for Authenticated users: read/write  Now we\u0026rsquo;ll have Amplify modify our cloud environment, provisioning the storage resources we just added.\n Run amplify push Press Enter to confirm the changes Wait for the provisioning to finish. Adding storage usually only takes a minute or two.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth.html",
	"title": "인증 추가하기",
	"tags": [],
	"description": "",
	"content": " 인증 추가하기  백엔드 구성하기   프론트엔드 렌더링   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql.html",
	"title": "GraphQL API 생성하기",
	"tags": [],
	"description": "",
	"content": " GraphQL API 생성하기  AppSync 세팅   Querie 수행하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/40_upload_photos_consolidated.html",
	"title": "Managing Photos",
	"tags": [],
	"description": "",
	"content": " Now that we have an S3 bucket where our photos can get stored, we\u0026rsquo;ll want to create a UI that lets us upload photos to that bucket for storage. We\u0026rsquo;ll also need to track that the photo was intended to be part of a specific album that it was uploaded to, so that we can eventually load all of the photos that belong to that album.\nLet\u0026rsquo;s create a new S3ImageUpload component that will contain an HTML file input element which will fire off an event handler when a user selects a photo.\nOur upload event handler will need to upload the file to S3 with some metadata annotating which album it's destined for. Luckily, the [Amplify JS Storage module](https://aws-amplify.github.io/amplify-js/media/storage_guide) makes uploading files to S3 very easy. Also, we'll need to introduce one new dependency to our app — a way to generate UUIDs — because we'll need to ensure that we're uploading files to S3 with unique names (if we used the filenames from users' devices, they could conflict).  From the photo-albums directory, run npm install --save uuid\nNow we\u0026rsquo;ll update our app by adding some imports, creating an S3ImageUpload component, and including the S3ImageUpload component in the AlbumDetails component.\nReplace photo-albums/src/App.js with this updated version: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } } `; class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } }  class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; }  \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed in src/App.js  Imported v4 as uuid from uuid\n Imported Divider and Form from semantic-ui-react\n Imported Storage from aws-amplify\n Imported S3Image from aws-amplify-react\n Updated GetAlbum query to support paginating photos\n Created new components: S3ImageUpload and PhotosList\n Updated AlbumDetailsLoader to support paginating photos\n Added PhotosList to AlbumDetails\u0026rsquo;s render output\n  Try uploading a photo At this point there\u0026rsquo;s not much to look at, but you should be able to click the button, select a file, and see it change to \u0026lsquo;Uploading…\u0026rsquo; before switching back to an upload button again.\nYou can also go manually explore the S3 bucket in the AWS web console to see that the files are getting uploaded. The easiest way to find the bucket name is to look at _src/aws-exports.js_ and find the value configured for __aws_user_files_s3_bucket__. Find your bucket in the S3 web console, then look in the bucket under _public/uploads_.  There are a few things worth calling out in our new _S3ImageUpload_ component. It uses AWS Amplify's _Storage.put_ method to upload a file into the S3 bucket we configured for our app. In this API call, we're passing in a few extra options.  We pass in _customPrefix: { public: 'uploads/' }_ because we'll want to automatically make thumbnails for each image. We'll accomplish this shortly by adding a trigger onto the S3 bucket that will fire off a thumbnail creation function for us each time any file is added to the _uploads/_ path of the bucket. New thumbnails will also get added to the bucket and to avoid a recursive trigger loop where each thumbnail creation then causes the function to fire again, we'll scope our trigger to only execute for files that are added with a key prefix of _uploads/_. Amplify knows to use our prefix because we specified that it was for files that should be publicly accessible, which is the default permission level for Storage.put.  Is it a problem that the default is for all files to be accessible (at the API level) to any of our users in the app? No. This is acceptable since we're using unguessable UUIDs for the photo keys, and users will only be able to retrieve a list of photos for an album if they know that album's UUID as well. If you go read all of the Amplify Storage module's API (or if you're familiar with the underlying S3 API), you might ask “but wait, users can just list all of the objects in the public path and see all of the photos!” For now, you're right, but we'll deal with that later, after our app is working and we take additional precautions to lock it down further (by restricting album listing to certain usernames and by preventing users from listing items in the bucket).  We pass in metadata: _{ albumid: this.props.albumId }_ because we're going to have an S3 thumbnail trigger function take care of adding the information about this photo to our data store after it finishes making the thumbnail, and that function will somehow need to know what album the photo was uploaded for. We could have put the album ID in the photo key as a prefix or suffix, for example, but the metadata approach feels more appropriate. After all, this *is* metadata about the photo, right?  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/40_searching_for_labels.html",
	"title": "Searching Photos By Label",
	"tags": [],
	"description": "",
	"content": " With all of the back-end work completed, now we just need to update our web app to allow searching for photos by label.\nLet\u0026rsquo;s create a new Search component and add it to the App component to be rendered on the root path. For rendering all of the matching photos in the Search component, we\u0026rsquo;ll re-use the PhotosList component we already created.\nReplace photo-albums/src/App.js with the following: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } }  class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt;  \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nWhat we changed  Added a SearchPhotos query to find photos for a given label.\n Added a Search component that uses the SearchPhotos query to get a list of matching photos for a given label and renders the photos using the pre-existing PhotosList component.\n Added the SearchPhotos component to render as part of the root \u0026lsquo;/\u0026rsquo; path.\n  Testing the photos search With that done, you should be able to go back to the root path \u0026lsquo;/\u0026rsquo; in the web app and try out the search.\nNote that when Amplify sets up the Amazon Elasticsearch Service integration, it will only index new data because it doesn\u0026rsquo;t pass the existing data from DynamoDB at the time of creation. You\u0026rsquo;ll need to upload a few more photos to an album before you\u0026rsquo;ll see search results.\nGive it a shot!\nBefore trying to search for a photo, please make sure that the `amplify push` from the previous page has finished.   To test out the photo search, look in the Photos table in DynamoDB for some valid labels to use as search terms. You must enter a label that matches exactly with one that was detected by Rekognition.  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums.html",
	"title": "Working With Albums",
	"tags": [],
	"description": "",
	"content": " Working With Albums  Managing Albums   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos.html",
	"title": "Managing Photos",
	"tags": [],
	"description": "",
	"content": " Managing Photos  Adding Cloud Storage   Managing Photos   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails.html",
	"title": "Generating Thumbnails",
	"tags": [],
	"description": "",
	"content": " Generating Thumbnails  Creating a Photo Processor Lambda function   Connecting the photos bucket to the processor function   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai.html",
	"title": "Adding AI",
	"tags": [],
	"description": "",
	"content": " Adding AI  Integrating Amazon Rekognition   Making Photos Searchable   Searching Photos By Label   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying/10_deploying.html",
	"title": "Deploying our app to S3",
	"tags": [],
	"description": "",
	"content": "Before we build and publish our app, we should free up some memory on the Cloud9 instance. If you\u0026rsquo;re using a micro Cloud9 instance size, there\u0026rsquo;s a good chance there won\u0026rsquo;t be enough memory available to keep our development web server running and to create a production build.\n Go to the terminal tab that\u0026rsquo;s running the development webserver (where you ran npm start)\n Press Control-C to interrupt the development webserver and kill it.\n  The AWS Amplify CLI makes it easy to deploy our app to a publicly accessible bucket on S3.\n Run amplify hosting add, select a deployment mode (for this workshop, select \u0026lsquo;Development\u0026rsquo;), and respond to the questions (you can accept the default value of index.html for the index and error doc).\n$ amplify hosting add ? Select the environment setup: DEV (S3 only with HTTP) ? hosting bucket name photoalbums-19700101010203--hostingbucket ? index doc for the website index.html ? error doc for the website index.html Run amplify push\n Wait for the new S3 bucket that will serve our app\u0026rsquo;s static content is created. This usually takes about a minute.\n Run amplify publish\n Wait while Amplify builds a production version of our app and deploys it to the hosting bucket. This process usually takes a minute or two.\n  After the build and deploy finishes, you\u0026rsquo;ll see a URL for the version of deployed app. Any time you make new changes to the app, just re-run amplify publish whenever you want to push a new build out.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying.html",
	"title": "Publishing Our App",
	"tags": [],
	"description": "",
	"content": " Publishing Our App  Deploying our app to S3   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up.html",
	"title": "마무리하기",
	"tags": [],
	"description": "",
	"content": " 마무리하기  축하드립니다!   리소스 삭제하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus.html",
	"title": "Bonus Content",
	"tags": [],
	"description": "",
	"content": " Bonus Content  Making a Lightbox for Viewing Fullsize Photos   Allowing Other Users To Collaborate In Albums   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]